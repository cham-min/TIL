# 목차

- [TypeScript 타입 종류](#typescript-타입-종류)
  - [The primitives](#the-primitives)
    - [null, undefined](#null-undefined)
  - [Object Types](#object-types)
    - [Property Modifiers(속성 수정자)](#property-modifiers속성-수정자)
      - [Optional Properties(선택적 속성)](#optional-properties선택적-속성)
      - [readonly Properties](#readonly-properties)
    - [Index Signatures](#index-signatures)
    - [Arrays](#arrays)
  - [Functions](#functions)
    - [void](#void)
    - [Function Overloads](#function-overloads)
  - [Literal Types](#literal-types)
    - [Literal Inference](#literal-inference)
  - [any](#any)
  - [unknown](#unknown)
  - [Tuple](#tuple)
  - [Union Types](#union-types)
  - [Type Aliases](#type-aliases)
  - [Interfaces](#interfaces)
  - [Intersection Types](#intersection-types)
  - [Type Assertions](#type-assertions)
  - [never](#never)
  - [Enums](#enums)
- [Ref](#ref)

<br>

# TypeScript 타입 종류

## The primitives

- string
- number
- boolean
- null
- undefined
- bigint
- symbol

```typescript
// 변수 타입 표기 - 변수의 타입을 지정한다.
const num: number = 1;
const str: string = '문자열';
const bool: boolean = true;
const nullable: null = null;
const undefineable: undefined = undefined;
const big: bigint = 100n;
const sym: symbol = Symbol('name');
```

<br>

### `null`, `undefined`

값이 없거나 초기화되지 않은 값을 가리키는 원시값이다.

```typescript
const nullable: null = null;
const undefineable: undefined = undefined;

// null, undefined는 서로 다른 타입이다.
nullable = undefined; // ERROR
undefineable = null; // ERROR
```

<br>

tsconfig.json의 `strictNullChecks` 옵션에 따라서 동작 방식이 달라진다.

- `strictNullChecks: true` 경우

  - 모든 데이터 타입은 `null` 값을 할당할 수 없다.

    ```typescript
    let name: string = null; // ❌ string 타입에 null 타입 할당

    // null 값을 할당하기 위해서는 any, union 타입을 활용
    let name: string | null = null;
    ```

  - `null`과 `undefined`일 때, 해당 값의 메서드 혹은 속성을 사용하기 전에 값을 테스트해야 한다.
  - 선택적 속성을 사용하기 전에 `undefined`를 확인하는 것처럼 타입 좁히기(narrowing)를 사용하여 `null`일 수 있는 값을 확인할 수 있다.

    ```typescript
    // `null` 혹은 `undefined`의 값을 가졌을 때 해당 값을 테스트해야 한다.
    const printName = (str: string | undefined) => {
      if (str === undefined) {
        // 아무런 동작을 하지 않음
      } else {
        console.log(str);
      }
    };
    ```

- `strictNullChecks: false` 경우

  - `null` 혹은 `undefined`의 값을 가져도 해당 값에 정상적으로 접근할 수 있다.
  - `null`과 `undefined` 값은 어떤 타입의 속성에도 할당될 수 있으며, null 검사가 없는 C#, Java의 동작 방식과 유사하다.

    ```typescript
    // null 검사의 부재는 버그의 주요 원인이 되며 해당 옵션을 설정하는 것을 권장한다.
    let name: string = null;
    ```

- **Non-null Assertion 연산자** - 명시적인 검사를 하지 않고 `null`, `undefined`를 제거할 수 있는 구문으로 `!` 연산자를 표현식 뒤에 붙여서 해당 값이 `null` 혹은 `undefined`가 아님을 단언한다.

  ```typescript
  const convertToUpperCase = (str: string | null) => {
    return str!.toUpperCase();
  };
  ```

<br>

<br>

## Object Types

JavaScript에서 데이터를 그룹화하고 전달하는 기본적인 방법은 객체를 통해서이다. TypeScript에서는 이러한 객체를 객체 타입(object types)으로 표현하며, 익명, 인터페이스, 타입 별칭으로 정의할 수 있다.

```typescript
// 1. 익명
function greet(person: { name: string; age: number }) {
  return 'Hello ' + person.name;
}

// 2. 인터페이스
interface Person {
  name: string;
  age: number;
}

function greet(person: Person) {
  return 'Hello ' + person.name;
}

// 3. 타입 별칭
type Person = {
  name: string;
  age: number;
};

function greet(person: Person) {
  return 'Hello ' + person.name;
}
```

<br>

객체 타입은 프로퍼티와 각 프로퍼티 타입을 나열한다. 각 프로퍼티 타입 표기는 선택 사항이며, 타입을 지정하지 않으면 `any`로 간주한다.

```typescript
const person: {
  name: string;
  age: number;
  hobbies: string[];
} = {
  name: '최개발',
  age: 28,
  hobbies: ['Game', 'Swimming'],
};
```

<br>

### Property Modifiers(속성 수정자)

객체 타입에서 각 속성은 타입, 속성의 선택적(optional) 여부, 속성의 쓰기 가능(writable) 여부를 지정할 수 있다.

<br>

#### Optional Properties(선택적 속성)

특정 속성이 설정될 수도 있고 아닐 수도 있는 객체를 다룰 때가 있다. 이런 경우, 해당 속성 이름 끝에 `?`를 추가하여 선택적 속성으로 표시할 수 있다.

```typescript
interface IName {
  first: string;
  last?: string;
}

function printName(name: IName) {
  // ...
}

printName({ last: '최' }); // ❌
printName({ first: '개발' }); // ⭕️
printName({ first: '개발', last: '최' }); // ⭕️
```

선택적 속성을 읽을 수도 있다. `strictNullChecks`가 설정된 경우 TypeScript에서는 해당 속성이 잠재적으로 `undefined`일 수 있다고 알려준다.

```typescript
function printName(name: IName) {
  // (property) IName.first: string
  let firstName = name.first;
  // (property) IName.last?: string | undefined
  let lastName = name.last;
}
```

JavaScript에서는 속성이 설정된 적이 없더라도 접근이 가능하며 `undefined` 값을 제공한다. `undefined`는 아래와 같은 방식으로 처리가 가능하다.

```typescript
// 1. 삼항 연산자 기본값 처리
function printName(name: IName) {
  let firstName = name.first;
  let lastName = name.last === undefined ? '' : name.last;
}

// 2. Default Parameter(매개변수 기본값)
// ➡️ 매개변수 구조 분해 패턴을 사용하고 last에 기본값 제공
// ➡️ last가 printName 본문 내에서는 확실히 존재하고 호출하는 쪽에서는 선택적으로 제공할 수 있음
function printName({ first, last = '최' }: IName) {
  console.log(first, last);
}
```

<br>

#### readonly Properties

TypeScript에서 속성은 `readonly`로 표시될 수 있다. `readonly`로 표시된 속성은 런타임 동작을 변경하진 않지만, 타입 검사 중에 쓰기가 불가능하다.

```typescript
interface SomeType {
  readonly prop: string;
}

function doSomething(obj: SomeType) {
  console.log(obj.prop); // 읽기 가능

  // Cannot assign to 'prop' because it is a read-only property.
  obj.prop = 'hello'; // 재할당 불가
}
```

<br>

하지만 `readonly` 속성이 완전히 불변함을 의미하진 않는다. 내부 내용을 변경할 수 없다는 뜻은 아니며, 속성 자체를 다시 쓸 수 없다는 의미이다. 즉, `readonly`로 표시한 속성 자체의 재할당만 막을 뿐이지 속성이 가리키는 객체의 내부의 값들은 자유롭게 변경할 수 있다.

```typescript
interface Home {
  readonly resident: { name: string; age: number };
}

function visitForBirthday(home: Home) {
  console.log(`Happy birthday ${home.resident.name}!`);
  // home.resident 속성의 객체 내부 값 업데이트 가능
  home.resident.age++;
}

function evict(home: Home) {
  // home의 resident 속성 자체에는 재할당 불가
  home.resident = {
    // Cannot assign to 'resident' because it is a read-only property.
    name: 'Victor the Evictor',
    age: 42,
  };
}
```

<br>

#### Index Signatures

타입의 모든 속성 이름을 미리 알 수 없지만, 값의 형태를 알고 있는 경우가 있다. 해당 경우 인덱스 시그니처를 사용하여 미리 정의되지 않은 속성들의 타입을 지정할 때 사용한다. 즉, 객체에 동적으로 속성을 추가할 수 있게 해주는 문법이다.

```typescript
interface 인터페이스명 {
  [키이름: 키타입]: 값타입;
}
```

키 타입으로는 `string`, `number`, `symbol`, 템플릿 문자열 패턴의 타입만 가능하다. 문자열 키를 사용하는 전화번호부 같은 객체를 생성할 때 아래와 같이 사용할 수 있다.

```typescript
interface PhoneBook {
  [name: string]: string;
}

const phoneBook: PhoneBook = {
  철수: '010-1234-1234',
  영희: '010-1234-5678',
  민수: '010-8765-4321',
};

phoneBook['홍길동'] = '010-1111-2222'; // OK
```

<br>

여러 타입의 인덱스 시그니처를 사용할 수도 있다. `number`와 `string` 인덱서를 사용할 때 주의할 점은 `number` 인덱서에서 반환되는 타입이 `string` 인덱서에서 반환되는 타입의 서브타입이어야 한다. 이는 JavaScript가 `number`로 인덱싱할 때 실제로는 객체에 인덱싱하기 전에 `string`으로 변환하기 때문이다. 즉, `100`으로 인덱싱하는 것은 `"100"`으로 인덱싱하는 것과 같은 의미이다.

```javascript
const obj = {};
obj[100] = '숫자 인덱스 사용';
console.log(obj['100']); // 숫자 인덱스 사용
console.log(obj[100]); // 숫자 인덱스 사용
```

<br>

`number` 인덱싱이 `string` 인덱싱으로 자동 변환되는 JavaScript 동작 때문에 TypeScript에서는 `number` 인덱서의 반환타입은 `string` 인덱서의 반환 타입의 서브타입이어야 한다는 규칙을 강제하고 있다.

```typescript
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

interface NotOkay {
  [x: number]: Animal;
  // 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.
  [x: string]: Dog;
}
```

`NotOkay` 인터페이스에서 에러가 발생하는 이유는 아래와 같이 타입이 변환되면서 타입에 모순이 발생하기 때문이다.

```typescript
interface NotOkay {
  [x: number]: Animal;
  [x: string]: Dog;
}

const notOkay: NotOkay = /* ... */;
const result1 = notOkay[0]; // Animal 타입
const result2 = notOkay['0']; // Dog 타입
// 숫자 인덱서가 문자열 인덱서로 변환되면 Animal ➡️ Dog로 변환되는건데 Animal은 Dog로 취급할 수 없음

const myCat: Animal = { name: '냥이' };
const myDog: Dog = myCat; // ❌ Animal은 Dog로 취급 불가
```

반대로 `string` 인덱서의 반환 타입이 상위 타입인 경우는 에러가 발생하지 않는다. 위 예시에서 Dog는 Animal로 취급할 수 있기 때문이다.

```typescript
interface Okay {
  [x: number]: Dog;
  [x: string]: Animal;
}

const okay: Okay = /* ... */;
const result1 = okay[0]; // Dog 타입
const result2 = okay['0']; // Animal 타입

const myDog: Dog = { name: "바둑이", breed: "진돗개" };
const myAnimal: Animal = myDog;
```

<br>

추가로 문자열 인덱스 시그니처의 경우 dictionary 패턴을 표현하는 대표적인 방법인데 모든 속성이 반환 타입과 일치하도록 강제한다. 다음 예시에서 `name` 속성의 타입이 인덱스 타입과 일치하지 않아서 타입 검사기에서 에러가 발생한다. 이는 문자열 인덱스 `obj.name` 속성에 접근할 때 `obj['name']`과 같은데 인덱스 타입과 일치하지 않아서 에러가 발생한다.

```typescript
interface NumberDictionary {
  [index: string]: number;

  length: number; // ⭕️
  name: string;
  // Property 'name' of type 'string' is not assignable to 'string' index type 'number'.
}
```

만약 인덱스 시그니처가 속성 타입들의 유니온이라면 다른 타입의 속성들도 허용된다.

```typescript
interface NumberOrStringDictionary {
  [index: string]: number | string;
  length: number; // ⭕️
  name: string; // ⭕️
}
```

<br>

마지막으로 인덱스에 대한 할당을 방지하기 위해서 인덱스 시그니처를 `readonly`로 선언할 수 있다.

```typescript
interface ReadonlyStringArray {
  readonly [index: number]: string;
}

let myArray: ReadonlyStringArray = getReadOnlyStringArray();
myArray[2] = 'Mallory';
// Index signature in type 'ReadonlyStringArray' only permits reading.
```

이는 불변 설정 객체나 React에서 props를 직접 수정하지 못하도록 보호할 때와 같은 상황에서 유용하게 사용할 수 있다.

```typescript
// 불변 설정 객체
interface AppConfig {
  readonly [key: string]: string | number | boolean;
}

const config: AppConfig = {
  apiUrl: 'https://api.example.com',
  timeout: 3000,
  debugMode: false,
};

// 읽기는 가능
console.log(config.apiUrl); // ✅ OK

// 수정은 불가능
config.apiUrl = 'https://new-api.com'; // ❌ 에러!
config.newSetting = true; // ❌ 에러!
```

```typescript
interface ReadonlyProps {
  readonly [prop: string]: any;
}

// 컴포넌트가 props를 직접 수정하지 못하도록 보호
function MyComponent(props: ReadonlyProps) {
  // props.title = "new title";  // ❌ props 수정 불가

  // 대신 state나 새 변수 사용
  const [title, setTitle] = useState(props.title);
}
```

<br>

### Arrays

`Type[]`와 같은 구문으로 `number[]`, `string[]`, `boolean[]`와 같이 사용한다. 제네릭의 `Array<Type>`와 같은 의미이며, 튜플의 `[Type]`와는 다른 의미이다.

```typescript
// number[] - number 타입만 허용
const nums: number[] = [1, 2, 3];

// string[] - string 타입만 허용
const strs: string[] = ['가', '나', '다'];

// boolean[] - boolean 타입만 허용
const bools: boolean[] = [true, false];

// any[] - 모든 타입 허용
const anys: any[] = [1, '가', true];

// 명시한 특정 타입 허용
const specific: (number | string)[] = [1, '가'];
```

<br>

## Functions

TypeScript는 함수의 입력 및 출력 타입을 지정할 수 있다. 익명 함수의 경우 함수가 어떻게 호출되는지 알아내고 매개 변수에 자동으로 타입을 부여한다. 아래 코드를 살펴보면 함수에 대한 문맥적 타이핑(contextual typing)으로 매개변수 `name`은 `string`으로 타입 추론된다.

<img width="353" alt="image" src="https://user-images.githubusercontent.com/96946274/229846050-82081996-77c2-4022-9da8-e8196b70a562.png">

<br>

```typescript
// 1. 매개변수 타입 표기
const greet = (name: string) => {
  console.log('Hello, ' + name);
};
greet(42); // ❌ 런타임 에러 발생

// 2. 반환 타입 표기
// ➡️ 반환 타입을 추론하기 때문에 일반적으로 필요하지 않지만, 개인 선호도에 따라서 문서화 목적과 우발적 변경 방지를 위해 작성하곤 한다.
const getNumber = (): number => {
  return 28;
};

// 3. Promise 반환 함수
async function getFavoriteNumber(): Promise<number> {
  return 30;
}

// 4. Function 타입 표기
const add = (num1: number, num2: number) => {
  return num1 + num2;
};
let combineValues: Function;
combineValues = add;

// 어떤 타입의 매개변수를 받고, 어떤 타입의 값을 반환할지 명확하게 설정할 수 있다.
let addValues: (a: number, b: number) => number;

// callback 함수 만들어보기
const addHandle = (num1: number, num2: number, cb: (num: number) => void) => {
  const result = num1 + num2;
  cb(result);
};
addHandle(1, 2, (result) => {
  console.log(result);
}); // 3
```

<br>

## Literal Types

구체적인 문자열, 숫자 값을 가지는 타입이다. JavaScript에서 `var`, `let`은 변수의 값 변경을 허용하고 `const`는 허용하지 않는다. TypeScript에서는 이러한 차이가 리터럴 타입 생성에 반영된다.

changingString은 어떤 문자열을 나타낼 수 있기에 TypeScript는 타입 시스템에서 `let changingString: string`와 같이 `string`으로 추론한다.

```typescript
// let changingString: string
let changingString = 'Hello World';
changingString = '헬로 월드';
```

<br>

constantString은 단 하나의 가능한 문자열만 나타낼 수 있으므로 리터럴 타입으로 `const constantString: "Hello World"`와 같이 추론된다. 이처럼 TypeScript는 알아서 리터럴 타입으로 추론하므로 `let`으로 변수를 선언하여 리터럴 타입을 표기할 이유는 없다.

```typescript
const constantString = 'Hello World';
```

<br>

오직 하나의 값만을 가질 수 있는 변수는 유용하지 않지만 리터럴을 유니온(union)으로 조합하면 훨씬 유용한 개념을 표현할 수 있다. 예시로 `boolean`타입은 실제로는 리터럴 타입으로 `true | false`의 type aliase이다.

```typescript
// const로 선언한 변수는 리터럴 타입으로 추론된다.
const num = 1; // const num: 1

// 리터럴 타입으로 지정한 값만 허용된다.
const printName = (username: string, alignment: 'left' | 'center' | 'right') => {
  // ...
};

printName('최개발', 'left'); // ⭕️
printName('심개발', 'centre'); // ❌ Argument of type '"centre"' is not assignable to parameter of type '"left" | "center" | "right"'.
```

<br>

문자열, 숫자형과 같은 원시 자료형 리터럴 타입 외에도 객체를 표시하는 리터럴 타입이 있다. 주의할 점은 함수 리터럴 타입 반환값 표기는 `:` 대신 `=>`를 사용한다. 함수 리터럴 타입에 매개변수와 반환값의 타입을 표기하면 실제값 타입 표기는 생략이 가능하다.

```typescript
// 객체 리터럴 타입
const obj: { name: '최개발' } = { name: '최개발' };

// 배열 리터럴 타입
const arr: [1, 2, 'three'] = [1, 2, 'three'];

// 함수 리터럴 타입
const func: (amount: number, unit: string) => string = (amount, unit) => amount + unit;
```

<br>

### Literal Inference

객체 리터럴 타입을 사용할 때 조심할 점이 있다. TypeScript는 의도한 것보다 리터럴 타입을 부정확하게 추론한다.

```typescript
const obj = { name: '최개발' }; // const obj: { name: string }
const arr = [1, 2, 'three']; // const arr: (string | number)[]
```

JavaScript의 객체는 `const`로 선언한 변수여도 수정할 수 있으므로, TypeScript는 수정 가능성을 염두하여 타입을 넓게 추론한다. 값이 변하지 않는 것이 확실하면 `as const`라는 접미사를 붙이면 된다.

```typescript
const obj = { name: '최개발' } as const; // const obj: { readonly name: '최개발' }
const arr = [1, 2, 'three'] as const; // const arr: readonly [1, 2, 'three']
obj.name = '심개발'; // ❌ Cannot assign to 'name' because it is a read-only property.
arr.push(4); // ❌ Property 'push' does not exist on type 'readonly [1, 2, "three"]'.
```

타입이 고정되어 추론되는데 `readonly` 수식어가 붙는다. 해당 수식어가 붙으면 값은 변경할 수 없다. JavaScript라면 객체와 배열의 변경이 문제없이 진행되지만, TypeScript에서는 에러가 발생한다. JavaScript에서는 실수로 객체를 변경하여 에러가 발생하는 일이 생기는데 TypeScript에서는 이를 엄격하게 통제할 수 있다.

<br>

이는 문자열에서도 동일하게 적용된다.

```typescript
declare function handleRequest(url: string, method: 'GET' | 'POST'): void;

const req = { url: 'https://example.com', method: 'GET' };
handleRequest(req.url, req.method); // ❌ Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.
```

`req.method`는 `"GET"`이 아닌 `string`으로 추론된다. `req` 객체 생성 시점과 `handleRequest` 함수 호출 시점 사이에 코드가 실행되어 `req.method`에 새로운 문자열이 할당될 수 있기 때문에 오류가 있다고 판단한다. 마찬가지로 타입 단언(type assertion)이나 `as const`를 사용하여 전체 객체를 리터럴 타입으로 변환할 수 있다.

```typescript
// 타입 단언 방법 1
// ➡️ `req.method`가 항상 리터럴 타입 "GET"을 갖도록 의도했다는 의미로 생성 후 다른 문자열이 해당 필드에 할당하는 것을 방지한다.
const req = { url: 'https://example.com', method: 'GET' as 'GET' };

// 타입 단언 방법 2
// ➡️ `req.method`가 `"GET"` 값을 가지고 있다는 것을 알고 있다는 의미이다.
handleRequest(req.url, req.method as 'GET');

// 전체 객체 리터럴 전환
const req = { url: 'https://example.com', method: 'GET' } as const;
handleRequest(req.url, req.method);
```

<br>

## `any`

TypeScript의 특별한 타입으로 특정 값이 타입 검사 오류를 발생시키지 않기를 원할 때마다 사용할 수 있다. 하지만 `any`는 TypeScript가 주는 장점인 타입 검사 시스템을 모두 우회하여 JavaScript를 쓰는 것과 같게 된다. 아래의 경우를 제외하고는 `any`를 사용하지 않는 것이 좋다.

- 특정 값으로 인하여 타입 검사 오류가 발생하는 것을 원하지 않는 경우 _(특정 코드가 문제 없음을 TypeScript에 확신시키기)_
- 어떤 값 혹은 데이터가 저장될지 알 수 없는 경우

```typescript
let anyType: any;

// 어느 값을 할당하여도 타입 에러가 발생하지 않는다.
anyType = 1;
anyType = '가';
anyType = true;
```

<br>

### `noImplicitAny`

보통의 경우 타입 검사를 받지 않는 `any`를 사용하고 싶지 않을 것이다. `any`를 에러로 표시하고 싶다면 **tsconfig.json**에 설정된 `noImplicitAny` 설정 값을 `true`로 설정한다.

<br>

### `unknown`

사용자가 어떤 값을 입력할지 모르는 경우 사용한다.

```typescript
let unknownUserInput: unknwon;
let userName: string;

// any와 비슷하게 어떤 타입이든 에러 없이 저장이 가능하다.
unknownUserInput = 1;
unknownUserInput = '가';

// string 타입의 변수에 unknown 타입 값을 할당하면 에러가 발생한다.
userName = unknownUserInput; // Type 'unknown' is not assignable to type 'string'.

// string 타입의 변수에 any 타입 값을 할당하면 에러가 발생하지 않는다.
let anyUserInput: any = 1;
userName = anyUserInput; // any는 타입확인을 수행하지 않음

// unknown을 다른 변수에 할당하고 싶을 때는 타입 검사를 진행하면 된다.
if (typeof unknownUserInput === 'string') userName = unknownUserInput;
```

<br>

### Tuple

아이템 순서를 설정하고, 각 아이템은 지정된 타입만 허용된다.

```typescript
// 올바른 방법
let person: [string, number] = ['최개발', 28];

// Tuple과 일치하지 않는 요소가 들어간 경우 아래와 같은 에러가 발생한다.
// Type '[string, number, boolean]' is not assignable to type '[string, number]'.
// Source has 3 element(s) but target allows only 2.
person: [string, number] = ['최개발', 28, true];

// Tuple과 일치하면 재할당도 가능하다.
person = ['김개발', 24]; // OK
person = [26, '이개발']; // ERROR

// Tuple은 push를 예외적으로 허용되기에 에러가 발생하지 않는다.
person.push('김개발'); // ['최개발', 28, '김개발']

// push를 예외적으로 허용하지만 허용한 타입이 아닌 경우 아래와 같은 에러가 발생한다.
// Argument of type 'boolean' is not assignable to parameter of type 'string | number'.
person.push(true);
```

<br>

#### void

값을 반환하지 않는 함수의 반환 값을 의미하며 `return`문이 없거나 명시적으로 값을 반환하지 않았을 때 추론되는 타입이다.

```typescript
// 타입 추론된 반환 값은 void이다.
const noop = () => {
  return;
};
```

<br>

#### Function Overloads

함수의 다양한 signature를 지원하는 기능으로 동일한 함수의 이름으로 다양한 매개변수 유형과 반환 유형을 처리할 수 있다. 함수 시그니처에 대한 명시적인 유형 선언을 제공할 수 있고, 함수 호출 시 매개변수와 반환 값의 타입을 명확하게 지정할 수 있다.

```typescript
type Combinable = number | string;

function add(x: Combinable, y: Combinable) {
  if (typeof x === 'string' || typeof y === 'string') {
    return x.toString() + y.toString();
  }
  return x + y;
}

const result = add('최개발', '코딩중'); // const result: string | number
result.split(' '); // Property 'split' does not exist on type 'string | number'. Property 'split' does not exist on type 'number'.

const result2 = add('최개발', '코딩중') as string;
result2.split(' ');
```

위 예시의 경우 string 타입 두 개를 입력했지만 `result` 변수의 타입은 여전히 `string`으로 추론되는 게 아니라 `string | number`임을 확인할 수 있다. 그래서 `.split()` 메서드를 사용하지 못하여 타입 단언을 통해서 해결했다. 함수 오버로드를 통해서 함수를 더 유연하게 작성할 수 있다.

```typescript
type Combinable = number | string;

function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: Combinable, y: Combinable) {
  if (typeof x === 'string' || typeof y === 'string') {
    return x.toString() + y.toString();
  }
  return x + y;
}

const result = add(1, 2); // const result: number
```

<br>

#### Index Signatures

타입의 모든 속성 이름을 미리 알지 못하지만 값의 형태는 알고 있는 경우 사용한다. 객체 타입의 속성 이름을 동적으로 생성하며, 이를 통해서 객체의 키와 값의 유형을 명시적으로 선언하지 않고도 해당 객체의 속성에 접근할 수 있다.

객체 타입 내에 `[]`를 사용하여 정의되며, 대괄호 내에는 인덱스 이름과 인덱스에 대한 값을 설명하는 유형이 포함된다.

```typescript
// interface ErrorContainer { ... } 형태도 가능하다.
type ErrorContainer = {
  [prop: string]: string;
};

const errorBag: ErrorContainer = {
  email: '가능한 메일이 아닙니다',
  userName: '문자열로 시작해야 합니다.',
};
```

<br>

### Union Types

서로 다른 두 개 이상의 타입을 `|`로 구분하여 만들며, 각 타입을 멤버라고 부른다. Union 타입은 모든 멤버의 타입을 허용한다.

```typescript
let id: string | number;

id = 123;
id = '가나다';
id = true; // ERROR
```

Union 타입에 메서드를 사용하기 위해서는 모든 멤버에 유효한 작업이여야 한다.

```typescript
const printUpper = (str: string | string[]) => {
  console.log(str.toUpperCase());
  // Property 'toUpperCase' does not exist on type 'string | string[]'.
};

// typeof 타입 가드를 통해서 해결 가능하다(narrowing).
const printUpper = (strs: string | string[]) => {
  if (typeof strs === 'string') {
    console.log(strs.toUpperCase());
  } else {
    strs.forEach((str) => {
      console.log(str.toUpperCase());
    });
  }
};
```

<br>

### Type Aliases

같은 타입을 재사용하거나 타입에 이름을 붙이고 싶을 때 사용한다.

```typescript
// Object 타입 별칭. 이외에도 Primitive, Union 등 모든 타입을 저장할 수 있다.
type Person = {
  name: string;
  age: number;
};

const greet = (person: Person) => {
  console.log(person.name + ' is ' + person.age + ' years old');
};
greet({ name: '최개발', age: 28 }); // "최개발 is 28 years old"
```

<br>

### Interfaces

```typescript
interface Person {
  name: string;
  age: number;
}

const printPerson = (person: Person) => {
  console.log(person.name);
  console.log(person.age);
};
printPerson({ name: '최개발', age: 28 });
```

interface의 대부분 기능은 type alias에서도 가능하며 이름을 부여해주는 점이 동일하다. 차이점은 interface는 객체 타입에만 이름을 다는게 가능하지만, type alias는 모든 타입에 이름을 달 수 있다.

<img width="500" alt="image" src="https://user-images.githubusercontent.com/96946274/229854130-da06947b-7a2f-4334-ae7b-7261dcef25a9.png">

<br>

### Intersection Types

Interface를 사용하면 다른 유형에서 확장하여 새 유형을 만들 수 있다. TypeScript는 기존 객체 유형을 결합하는 데 교차 유형(Intersection types)라는 구조를 제공하며 `&` 연산자를 사용하여 정의된다.

```typescript
interface Colorful {
  color: string;
}
interface Circle {
  radius: number;
}

type ColorfulCircle = Colorful & Circle;
```

<br>

### Type Assertions

TypeScript가 추론한 타입보다 본인이 타입에 대한 정보를 더 정확히 아는 경우 타입 단언을 통해서 조금 더 구체적으로 명시할 수 있다. 보다 구체적이거나 덜 구체적인 타입으로 변환하는 것만 허용되며 숫자형을 문자형으로 assertion 하는 것은 불가능하다.

```typescript
// TypeScript는 document.getElementById는 HTMLElement 중 무언가 반환된다는 것만 알고있다.
// const myCanvas: HTMLElement | null로 타입 추론
const myCanvas = document.getElementById('main_canvas');

// type assertion
const myCanvas2 = document.getElementById('main_canvas') as HTMLCanvasElement;

// type assertion2
const myCanvas2 = <HTMLCanvasElement>document.getElementById('main_canvas');
```

<br>

### never

일반적으로 함수의 리턴 타입으로 사용된다. 리턴 타입으로 `never`를 사용하면 오류를 출력하고 리턴 값을 생성하지 않음을 의미한다.

```typescript
const generateError = (message: string, code: number) => {
  throw { message: message, errCode: code };
};
generateError('에러 발생', 500);
```

<br>

### Enums

- 멤버라고 불리는 명명된 값의 집합을 이루는 자료형이다.
- 숫자로 표현하지만 사람이 읽기 쉽게 라벨링하는 개념이다.
- 해당 라벨들은 0부터 시작하는 숫자로 변환된다.
- 사용자 지정 타입이므로 첫 글자는 대문자로 입력하는 컨벤션을 지킨다.

```typescript
// Numeric enums
enum Direction {
  Up, // 0
  Down, // 1
  Left, // 2
  Right, // 3
}
console.log(Direction.Up); // 0

// Numeric enums 값 할당 가능. 값이 할당되지 않은 멤버는 이전 멤버 +1된 값이 할당된다.
enum Direction {
  Up = 10, // 10
  Down, // 11
  Left = 100, // 100
  Right, // 101
}
console.log(Direction[101]); // "Right"

// String enums - 각 멤버는 문자열 리터럴 또는 다른 문자열 열거형 멤버로 상수 초기화 해야 한다.
enum Direction {
  Up = 'UP',
  Down = 'DOWN',
  Left = 'LEFT',
  Right = 'RIGHT',
}
```

<br>

**Enums를 사용하는 이유**

1. 역할을 부여하는 코드를 작성했다고 가정해본다.
   ```typescript
   // 0 : DEVELOPER
   // 1 : ADMIN
   // 2 : GUEST
   const person = {
     name: '최개발',
     role: 0,
   };
   ```

<br>

2. 해당 숫자 '0'만으로는 개발자, 관리자, 게스트 중 어떤 역할을 수행하는지 알기 어려우며, 문자로된 식별자인 'DEVELOPER'가 이해하기 쉬울 것이다.
   ```typescript
   const person = {
     name: '최개발',
     role: 'DEVELOPER',
   };
   ```

<br>

3. 다만 문자로된 식별자는 if문으로 권한을 확인할 때 'DEVELOPER'로 작성했는지 'developer'로 작성했는지 확신하기 어렵다. 문자열을 어떻게 작성했는지 정확하게 기억해야하는 단점이 있다.
   ```typescript
   if (person.role === 'DEVELOPER') {...} // O
   if (person.role === 'developer') {...} // X
   ```

<br>

4. 3 번의 경우 보통 전역 상수를 선언하여 해결하곤 한다.

   ```typescript
   const DEVELOPER = 0;
   const ADMIN = 1;
   const GUEST = 2;

   if (person.role === DEVELOPER) {...}
   ```

<br>

5. 전역 상수로 선언한 경우 `role`은 `number` 타입으로 추론되어 입력하지 않은 모든 숫자가 저장된다. 또한 전역 상수를 선언하면 이 상수들을 정의하고 관리해야 한다. 지금까지의 문제점을 Enum을 통해 해결이 가능하다.

   ```typescript
   enum Role {
     DEVELOPER, // 0
     ADMIN, // 1
     GUEST, // 2
   }

   const person = {
     name: '최개발',
     role: Role.DEVELOPER,
   };

   if (person.role === Role.DEVELOPER) {...}
   ```

<br>

# Ref

- [TypeScript Docs](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
