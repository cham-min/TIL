# 인증(Authentication) & 인가(Authorization)

## 인증은 왜 필요한가?
- 우리 서비스를 누가 어떻게 사용하고 있는지 추적이 가능하도록 하기 위함
- 인증에 필요한 것
  - `ID`, `password`, `E-mail`
  - `password`를 제외한 대부분의 정보는 이미 노출되어 있지만, `password`는 본인만 인증할 수 있기 때문에 중요한 부분

## 비밀번호는 어떻게 관리해야 하는가?
<blockquote>
개인정보보호법은 개인정보의 암호화에 대해서 다음과 같이 규정하고 있습니다.<br><br>
비밀번호, 바이오정보, 주민등록번호 등과 같은 주요 개인정보가 암호화되지 않고 개인정보처리 시스템에 저장되거나 네트워크를 통해 전송될 경우, 노출 및 위/변조 등의 위험이 있으므로 암호화 등의 안전한 보호조치가 제공되어야 한다.<br><br>
'암호화'는 개인정보취급자의 실수 또는 해커의 공격 등으로 인해 개인정보가 비인가자에게 유/노출 되더라도 그 내용 확인을 어렵게 하는 보안기술이다.<br><br>
즉, 시스템이 인터넷에서 격리된 네트워크에 위치하는 경우나, 예외적인 개인정보 항목을 다루는 경우를 제외하고는 국가에서 권고하는 상용 암호화 알고리즘을 이용해 개인정보를 암호화하도록 법적으로 요구하고 있습니다.
</blockquote>

![DB](https://user-images.githubusercontent.com/96946274/168549585-33372eb8-4201-4b7b-b061-332c799c302f.png)
- 암호화를 진행하면 '1234' 입력시 알아보기 힘든 `String` 형태로 저장
- 암호화를 시키지 않으면 `DB`가 뚫렸을 때, 비밀번호가 바로 드러나는 문제 발생
- `DB`에 저장시 개인 정보를 **해싱**하여 복원할 수 없도록 함
- 통신 시 개인 정보를 주고받을 때 SSL을 적용하여 암호화(`https`) 진행

## 암호화는 어떻게 하는가?
#### 단방향 해쉬
- 본래 해쉬 함수는 자료구조에서 빠른 자료의 검색, 데이터 위변조 체크를 위해서 쓰이지만 복원이 불가능한 `단방향 해쉬함수`는 암호화적 용도로 사용(원래의 값으로 복호화 되지 않음)
- 보안에 취약한 `MD5`, `SHA-1`이 있고, `SHA-256` 등이 있음
- '1234'를 해싱하면 다음과 같은 결과가 나온다 `03ac674216f3e15c761eee1a5e255f06...`
- 결과만 봐서는 당장 식별이 불가능 하므로 완벽해 보이지만 항상 같은 결과가 도출되는 알고리즘
  - 이는 데이터를 모아서 결과를 유추할 수 있게 만들고 이와 같은 허점을 이용해 가능한 경우의 수를 모두 계산한 해시 값으로 만들어 판매하는 서비스도 존재한다.
  - `Rainbow Table`이라고 불리며, `Rainbow table`을 이용해서 해시값을 유추하는 사이트
  - http://project-rainbowcrack.com/table.htm
  - https://crackstation.net/

#### Salting & KeyStretching
- 단방향 해쉬의 허점을 보완하고자 `salting`, `key stretching`가 등장
- 비밀번호와 임의로 생성한 문자열인 `salt`를 합쳐서 해싱하여 해시값을 지정하는 방법
- 비교를 위해 DB에 `해시값`과 `salt값`을 같이 저장해야 함
  - 암호화는 복원할 수 없어서 비밀번호를 맞추기 위해 새로 들어온 값을 저장된 `salt`값으로 해쉬하여 암호화 해보고 존재하는 값과 비교하는 과정이 필요하기 때문이다.
- `key stretching`은 해커가 무작위 대입을 통해 해시값을 계산하는데 필요한 시간을 대폭 늘리기 위해 `salting`, `해싱`을 여러번 반복해서 원본 값을 유추하기 어렵게 만드는 것
  - 단순한 1234에 `salt`값을 붙인 값 조차 `rainbow table`에 들어가 있을 것이다. `salting`을 여러번 반복하는 것은 완벽한 보안이 아닌 조금이나마 시간을 버는 과정으로 암호화는 완벽하지 않다.
  - 3개월만 지나면 비밀번호를 재설정 하라는 것은 완벽한 보안을 보장할 수 없기 때문에 해커가 테이블을 돌리는 최소한의 시간을 90일로 설정하고 비밀번호 변경을 권장하는 것이다.
  - 복호화 할 수 없지만, 어떤 값이 들어 왔을 때 해당 값이 나온다는 데이터는 누적할 수 있으며 컴퓨터 성능이 좋아질수록 그 결과는 빨리 나온다. 지금 단계에서 할 수 있는 것은 `서버`에 못들어오게 하거나 `DB`를 볼 수 없게 하는 것이 최선이다.

## bcrypt (Salting & Key Stretching 대표 라이브러리)
- `bcrypt`는 앞서 말한 개념을 실제로 적용하기 편하게 해주는 대표적 라이브러리
- 다양한 언어를 지원하고 있으며, 사용이 간편하여 쉽게 적용이 가능
- `bcrypt`는 `hash`결과 값에 `salt`값과 `해시값` 및 반복횟수를 같이 보관하기 때문에 비밀번호 해싱을 적용하는데 있어 `DB` 설계를 복잡하게 할 필요 없다.
- `bcrypt`를 통해 해싱된 결과(Digest)의 구조는 아래와 같다.

![Untitled](https://user-images.githubusercontent.com/96946274/168587437-040a7957-73e4-43d7-82d6-bba33aecd33e.png)

## 인가(Authorization)는 무엇인가?
- 해당 유저가 `request`에 해당하는 권한이 있는지 확인하는 절차
- `Http`의 특징
  - `request` / `response`
  - `stateless` 성질
- 서버는 사용자가 로그인 했을 경우, 로그인 했다는 것을 어떻게 알 수 있을까
  - `headers`에 메타데이터를 보내서 확인
  - 메타데이터를 `JSON Web Token`, 줄여서 `JWT`라고 한다.
  - 프론트엔드는 `JWT`를 받아서 다음 요청에 `headers`에 넣어두면, 백엔드가 `JWT`를 분석해서 재로그인 할 필요 없도록 한다.

## JSON Web Token
#### JWT의 구조
![JSON Web Token](https://user-images.githubusercontent.com/96946274/168588216-bf797920-8ce3-4475-b886-51c97dd79a30.png)

#### Header
- 토큰의 타입과 해시알고리즘 정보가 들어감
- 헤더의 내용은 `BASE64` 방식으로 인코딩해서 `JWT` 첫 부분에 기록
- 인코딩은 암호화가 아니기에 `header`에 개인정보를 넣는 것은 X
- ex. `{"alg": "HS256", "typ": "JWT"}`

#### Payload
- 본인이 확인할 수 있는 첫 번째 정보를 담음
- 만료 시간을 나타내는 `exp`와 같이 미리 정의된 집합인 `Registered Claim`
- 공개용 정보 전달을 목적으로 하는 `Public Claim`
- 클라이언트와 서버간 협의하에 사용하는 `Private Claim`
- 세 가지 요소를 조합하여 작성한 뒤 `BASE64`에 인코딩하여 두 번째 요소로 위치
- `payload` 또한 암호화 되지 않아서 개인정보를 담는게 아니라 서버만이 판단할 수 있는 `PK값`을 부여
- ex. `{"user-id": 1, "exp": 1539517391}`

#### Signature
- `JWT secret`이라는 서버만의 열쇠를 만들고 이를 암호화하여 저장함
- 여기서 사용하는 암호화는 복호화 가능
- `JWT`가 원본 그대로라는 것을 확인할 때 사용
- 시그니처는 `BASE64URL` 인코드된 `header`와 `payload` 그리고 `JWT secret`을 헤더에 지정된 암호 알고리즘으로 암호화하여 전송(복호화 가능)
- 프론트엔드가 `JWT`를 백엔드 `API 서버`로 전송하면 서버에서 받은 `JWT`의 서명부분을 복호화하여 서버에서 생성한 `JWT`가 맞는지 확인
