# Big O

### Big O 표기법의 필요성

*코드를 분류하거나 비교할 수 있는 시스템이 있다면 얼마나 좋을까? 제대로 작동하는 코드도 좋은 코드지만, 면접, 코드 챌린지, 수천 개의 데이터를 다루는 대기업의 경우 한 알고리즘이 다른 알고리즘보다 실행 속도가 더 빠른 성능이 더 중요하다. 또한 코드를 디버그할 때 에러만 찾는 것이 아니라 코드가 작동을 하지만 시간이 오래 걸리거나 브라우저에서 함수를 실행했을 때 코드를 느리게 만드는 것이 무엇인지 이해하는 것이 중요하다.*<br>

- 여러가지 코드를 서로 비교하고 성능을 평가하는 방법이다.
- Big O의 핵심은 한 가지 문제에 대해서 해결법이 두 가지가 존재할 때, 어느 것이 더 좋은지 알 수 있다.
- ‘좋은’, ‘보통’, ‘나쁨’ 이라는 단어 대신 수치로 코드의 성능을 표기할 수 있다.
- 가장 좋은 알고리즘은 존재하고, 코드의 성능을 이야기 할 때는 정확한 전문용어를 사용하는 것이 중요하다.
- 본인이 만든 해결책이 만족스럽더라도 다른 해결책과 비교하며 성능이 어떤지 이해하는 것이 도움된다.
-  Big O를 이해한다면 비효율적인 코드를 찾아내는데 도움이 된다.

Big O 표기법은 아래와 같다. 표기법에 대한 내용은 예제를 통해 이해하자.

- `O(1)` : 상수시간, 문제 해결에 한 단계만 처리
- `O(n)` : 직선적 시간, 문재 해결을 위해 n만큼 단계 필요
- `O(n^2)` : 2차 시간, 문제 해결을 위해 n제곱 만큼 단계 필요
- `O(log n)` : 로그 시간, 문제 해결을 위해 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬
- `O(n log n)` : 문제 해결을 위해 필요한 단계의 수가 n번에 그 하나의 n번당 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬

---

### 코드 시간 재기

**예시 1**

```
function addUpTo(num) {
    let total = 0;
    for (let i = 1; i <= num; i++) {
        total += i;
    }

    return total;
}

console.log(addUpTo(6)); // 21
```

**예시 2**

```
function addUpTo(num) {
    return num * (num + 1) / 2;
}

console.log(addUpTo(6)); // 21
```

예시 1, 예시 2 코드 중에서 어떤 코드가 더 나은 코드인가? 우선 **'더 나은'** 코드란 무엇을 의미하는지 이해하자.<br>
아래에 좋은 코드가 무엇일지 3 가지를 적어 놓았다. 세 예시 중 어떤 코드가 좋은 코드인지 생각해보자.

- Faster?
- Less memory-intensive?
- More readable?

<br>

### Timing Function 사용하기
대부분의 사람들은 가독성 보다 **속도와 메모리 사용량이 적은 것**이 더욱 중요하다고 말한다. 그렇다면 어떻게 속도를 측정할 수 있을까? 가장 쉬운 방법은 **Timing Function**을 사용하는 것이다.

💡`performance.now`를 사용하면 시작이후 경과된 시간을 나타내준다.

**예시 1**

```
function addUpTo(num) {
    let total = 0;
    for (let i = 1; i <= num; i++) {
        total += i;
    }

    return total;
}

let t1 = performance.now();
addUpTo(1000000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`); // Time Elapsed: 0.9767999999998137 seconds.
```

**예시 2**

```
function addUpTo(num) {
    return num * (num + 1) / 2;
}

let t1 = performance.now();
addUpTo(1000000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`); // Time Elapsed: 0.00009999999962747097 seconds.
```
똑같은 데이터를 다루지만 예시 2의 코드가 훨씬 더 빠른 시간 내에 해결됐음을 알 수 있다. 따라서 예시 2의 코드가 훨씬 효율적이며 더 좋은 코드로 보인다. 하지만 수동으로 timing을 구하고 서로 비교하는 것은 동료와 같이 논의하기도 어려우며 가장 좋은 방법은 아니다. 그러면 어떻게 작성하는 것이 좋을까? 두 코드의 속도를 봤을 때 얼마나 더 좋은지 어떻게 비교할 수 있을까? 아래 경우를 통해서 두 코드의 시간을 빼는 것으로는 충분하지 않다는 불확실함이 있다.

- 각 기기는 시간 값을 다르게 기록한다.
- 동일 기기라도 환경에 따라서 시간 값을 다르게 기록할 수 있다.
- 빠른 알고리즘에선 정말 빠른 시간 내에 모든 것이 처리되기 때문에 속도 측정 정확도가 충분하지 않다.


---

### 연산 갯수 세기

정말 빠른 알고리즘이 3~4개가 있을 때 Timing Function은 작은 차이를 측정하기 힘들다. 이러한 상황에서 코드 시간을 측정하지 않고 어느 코드가 더 좋은지 어떻게 평가할 수 있을까? 시간을 재는 것 보다는 컴퓨터가 처리하는 연산의 갯수를 세면 된다. 시간은 환경에 따라서 결과가 다르게 나올 수 있지만, 어떤 기기라도 연산의 갯수는 동일하다.

**예시 1**

```
function addUpTo(n) {
	return n * (n + 1) / 2;
}
```
`n`에 어떤 값이 들어와도 연산은 3 번 실행하며, 아래와 같다.

- 곱셈 1회
- 덧셈 1회
- 나눗셈 1회
<br>

**예시 2**

```
function addUpTo(n) {
	let total = 0;
	for (let i = 1; i <= n; i++) {
		total += i;
	}
	
	return total;
}
```
`n` 값에 따라서 `5n + 2` 만큼 연산을 진행하며, 아래와 같다.

- `let total = 0;` 할당 1회
-  `let i = 1` 할당 1회
- `i <= n` 비교  * `n` 수 만큼
- 후위 연산자 * `n` 수 만큼 
- 후위 연산자 할당 `n` 수 만큼 
- 덧셈 연산자 * `n` 수 만큼
- 할당 연산자 * `n` 수 만큼

**사실은 정확한 연산 숫자는 신경쓰지 않아도 된다.** 전체적인 추세를 보는 것이 중요하다. 예시 2의 경우는 `n` 값이 커질수록 연산의 갯수가 비례하여 증가한다. 자세한 내용은 아래에서 다뤄본다.

---

### Big O
Big O는 함수의 입력 값이 늘어나는 것과 함수 실행 시간이 변하는 관계를 의미한다. 

- linear => `O(n)`
- quadratic => `O(n^2)`
- constant => `O(1)`

일반적으로 Big O를 이야기 할 때는 실행시간이 가질 수 있는 최대치(가장 높은 실행 시간 값)를 말한다.

**예제 1**

```
function addUpTo(n) {
	return n * (n + 1) / 2;
}
```
- 언제나 연산 갯수는 3개이며, 시간이 상수이다.
- Big O로는 `O(1)`라고 표기할 수 있다.
- `n` 값이 커지더라도 아무런 변화가 없으며, 실행 시간이 변하지 않는다.

**예제 2**

```
function addUpTo(n) {
	let total = 0;
	for (let i = 1; i <= n; i++) {
		total += i;
	}
	
	return total;
}
```
- `n` 값이 커질수록 실행 시간이 1:1 비율로 늘어나며, 연산의 갯수는 `n`의 곱과 연결되어 있다.
- `1n`, `5n`, `10n` 어떤 값이든 상관 없으며, `O(n)`으로 단순하게 표현할 수 있다. 


**예제 3**

```
function countUpAndDown(n) {
	console.log("Going up!");
	
	for (let i = 0; i < n; i++) {
		console.log(i);
	}
	console.log("At the top!\nGoing down..."); // O(n)
	
	for (let j = n - 1; j >= 0; j--) {
		console.log(j);
	}
	console.log("Back down. Bye!"); // O(n)
}
```
- 첫 번째 `for` 루프, 두 번째 `for` 루프 모두 `O(n)`이며, 실행 시간은 1:1 비율로 증가한다.


**예제 4**

```
function printAllParis(n) {
	for (var i = 0; i < n; i++) {
		for (var j = 0; j < n; j++) {
			console.log(i, j);
		}
	}
}
```
- 예제 3 처럼 단순히`O(n)`이 두 개가 있는 것이 아니라 중첩되어 있다. 따라서 `O(n^2)`으로 표현할 수 있다.
- 이 경우는 `n`이 커질수록 실행 시간이 `n`제곱 값으로 늘어난다.

---

### Big O 표현식 단순화

이전 연산 갯수 세기 단원에서 아래 코드의 연산 갯수는 `5n + 2`라고 결론 내렸지만, 정확한 갯수는 중요하지 않다고 했다.

```
function addUpTo(n) {
    let total = 0;
    for (let i = 1; i <= n; i++) {
        total += i;
    }
    
    return total;
}
```
`5n + 2` 식을 `n`으로 단순화 할 수 있다. `n`값이 커질수록 실행 시간은 비례하여 증가할 것이고, `n * 2`이던지 `n * 1000`이던지 상관없이 그래프 선 추세가 `n` 값과 비례하기 때문에 다르지 않다고 할 수 있다.

#### Big O 식을 단순화 할 수 있는 규칙
- 상수는 중요하지 않다.
	- `O(2n)` => `O(n)`
	- `O(500)` => `O(1)`
	- `O(13n^2)` => `O(n^2)`
	- 산수는 상수이다. `1 + 2`, `999 * 888` 처리 속도는 같다.
- 작은 연산은 중요하지 않다.
	- `O(n + 10)` => `O(n)`
	- `O(1000n + 50)` => `O(n)`
	- `O(n^2 + 5n + 8)` => `O(n^2)`, (`n`제곱에 비해서 `5n + 8`은 의미가 없다)
- 변수 할당은 상수이다. `x = 1000`, `x = 9999999` 처리 속도는 같다.
- 배열 요소에 인덱스로 접근하는 것은 상수이다. `x[1]`, `x[99]` 처리 속도는 같다.
- 루프의 경우, 복잡도는 루프 내부에서 일어난 복잡성을 곱한 것이다. 중첩의 경우 `n`제곱 실행 시간이 될 수 있다.

#### 예시

```
function logAtLeast5(n) {
	for (let i = 1; i <= Math.max(5, n); i++) {
		console.log(i);
	}
}
```
- 위 예시의 경우 `n`은 5까지 가거나, `n`값 까지 반복할 것이다.
- `n`은 무한대 까지 증가할 수 있고 5는 별로 중요하지 않은 값이 된다.
- 위 함수의 Big O를 `O(n)`으로 단순화해서 표현할 수 있다. `n`이 커질수록 연산 횟수가 `n`에 비례해서 증가하기 때문이다.

```
function logAtMost5(n) {
	for (let i = 1; i <= Math.min(5, n); i++) {
		console.log(i);
	}
}
```
- 위 예시의 경우 5 혹은 더 작은 값을 선택하여 반복한다.
- 위 예시는 `n` 값이 커지더라도 아무 영향을 주지 않는다.
- `n`이 커질수록 Big O는 상수 `O(1)`로 단순화할 수 있다.

### 결론
앞으로 알고리즘을 풀이할 때 실행 시간이 `O(1)`, `O(n)`, `O(n^2)` 순으로 좋음을 분별할 수 있다.

---

### 공간 복잡도

입력의 크기가 증가함에 따라 알고리즘의 실행 시간을 분석하는데 집중했고, 이를 시간 복잡도라 한다. 지금 부터는 입력 크기가 증가함에 따라 알고리즘이 얼마나 많은 공간을 차지하는지 알아본다.

**보조 공간 복잡도** : 입력되는 값을 제외하고, 알고리즘 자체가 필요로 하는 공간

### 기본 규칙
- `Boolean`, `Numbers`, `Undefined`, `null`은 자바스크립트에서 불변 공간이다.
	- 입력의 크기와 상관없이 숫자가 1이든 1000이든 모두 불변 공간이라고 여긴다.
	- `Boolean`값이 `true`, `false`와 상관없이 똑같은 공간을 차지한다.
- `String`의 경우 `O(n)`의 공간이 필요하다.
	- `n`이 문자열의 길이인 경우, 50자를 입력할 경우 1자 입력한 문자열보다 50배 많은 공간을 차지한다.
-  `reference`타입(`Array`의 길이, `Object`key의 수) 대부분 `O(n)`의 공간이 필요하다.
	- 길이가 2, 4인 배열이 두 개가 존재할 때, 길이가 2인 배열보다 길이가 4인 배열이 두 배 더 많은 공간을 차지한다.

**예시 1**

시간 복잡도 대신 공간 복잡도를 집중해서 살펴보자.

```
function sum(arr) {
	let total = 0;
	for (let i = 0; i < arr.length; i++) {
		total += arr[i];
	}
	
	return total;
}
```	
- 매개변수 `arr`의 값이 커지더라도 공간은 `total`, `i`만 차지하고 있으므로 아무 상관 없다. 즉, 입력의 크기와는 상관없이 공간 복잡도는 항상 같다.
	- `let total = 0;`
	- `let i = 0;`
	- `total` 변수에 값을 더하는 것일 뿐, 새로운 변수를 만들지 않는다.
	- 이는 상수 공간이 있다는 의미이며 `O(1)` 공간이라 말할 수 있다.

**예시 2**

```
function double(arr) {
	let newArr = [];
	for (let i = 0; i < arr.length; i++) {
		newArr.push(2 * arr[i]);
	}
	
	return newArr;
}
```
- `let newArr = [];`에서 새로운 배열을 만든 후, 루프로 접근해서 새로운 배열 값을 반환한다.
- `arr` 값이 증가할수록 반환되는 `newArr`의 크기는 비례하여 증가한다.
- 따라서 `O(n)`의 공간을 차지한다고 할 수 있다.

---

### Ref

- 유데미 자바스크립트 알고리즘 & 자료구조 마스터 클래스
