# 목차

- [TypeScript 타입 종류](#typescript-타입-종류)
  - [The primitives](#the-primitives)
    - [null, undefined](#null-undefined)
  - [Object Types](#object-types)
    - [Property Modifiers(속성 수정자)](#property-modifiers속성-수정자)
      - [Optional Properties(선택적 속성)](#optional-properties선택적-속성)
      - [readonly Properties](#readonly-properties)
      - [Index Signatures](#index-signatures)
    - [Excess Property Checks(초과 속성 검사)](#excess-property-checks초과-속성-검사)
      - [초과 속성 검사가 발생하는 경우](#초과-속성-검사가-발생하는-경우)
        - [1. 직접 할당](#1-직접-할당)
        - [2. 함수 인수로 전달](#2-함수-인수로-전달)
        - [3. 함수 반환값으로 사용](#3-함수-반환값으로-사용)
      - [초과 속성 검사가 발생하지 않는 경우](#초과-속성-검사가-발생하지-않는-경우)
        - [1. 변수 간접 할당](#1-변수-간접-할당)
        - [2. 타입 호환성 확인](#2-타입-호환성-확인)
      - [초과 속성 검사 우회 방법](#초과-속성-검사-우회-방법)
        - [1. 타입 단언](#1-타입-단언)
        - [2. 인덱스 시그니처](#2-인덱스-시그니처)
        - [3. 변수를 통한 간접 할당](#3-변수를-통한-간접-할당)
    - [Extending Types(타입 확장)](#extending-typestype-확장)
      - [다중 상속과 중첩 확장](#다중-상속과-중첩-확장)
      - [Override(속성 재정의)](#override속성-재정의)
      - [Intersection Types(교차 타입)](#intersection-types교차-타입)
      - [Interface Extension vs. Intersection](#interface-extension-vs-intersection)
    - [Generic Object Types](#generic-object-types)
      - [The Array Types](#the-array-types)
      - [The ReadonlyArray Type](#the-readonlyarray-type)
      - [Tuple Types](#tuple-types)
      - [readonly Tuple Types](#readonly-tuple-types)
  - [Arrays](#arrays)
  - [Tuple](#tuple)
  - [Functions](#functions)
    - [void](#void)
    - [Function Overloads](#function-overloads)
  - [Literal Types](#literal-types)
    - [Literal Inference](#literal-inference)
  - [any](#any)
  - [unknown](#unknown)
  - [Union Types](#union-types)
  - [Type Aliases](#type-aliases)
  - [Interfaces](#interfaces)
  - [Intersection Types](#intersection-types)
  - [Type Assertions](#type-assertions)
  - [never](#never)
  - [Enums](#enums)
- [Ref](#ref)

<br>

# TypeScript 타입 종류

## The primitives

- string
- number
- boolean
- null
- undefined
- bigint
- symbol

```typescript
// 타입 주석(Type annotation) - 변수 뒤에 콜론(:)과 타입을 표기한다.
const num: number = 1; // 1, -1, 0.1, -0.1, Infinity, -Infinity, NaN
const str: string = '문자열';
const bool: boolean = true;
const nullable: null = null;
const undefineable: undefined = undefined;
const big: bigint = 100n;
const sym: symbol = Symbol('name');
```

<br>

### `null`, `undefined`

값이 없거나 초기화되지 않은 값을 가리키는 원시값이다.

```typescript
const nullable: null = null;
const undefineable: undefined = undefined;

// null, undefined는 서로 다른 타입이다.
nullable = undefined; // ERROR
undefineable = null; // ERROR
```

<br>

tsconfig.json의 `strictNullChecks` 옵션에 따라서 동작 방식이 달라진다.

- `strictNullChecks: true` 경우

  - 모든 데이터 타입은 `null` 값을 할당할 수 없다.

    ```typescript
    let name: string = null; // ❌ string 타입에 null 타입 할당

    // null 값을 할당하기 위해서는 any, union 타입을 활용
    let name: string | null = null;
    ```

  - `null`과 `undefined`일 때, 해당 값의 메서드 혹은 속성을 사용하기 전에 값을 테스트해야 한다.
  - 선택적 속성을 사용하기 전에 `undefined`를 확인하는 것처럼 타입 좁히기(narrowing)를 사용하여 `null`일 수 있는 값을 확인할 수 있다.

    ```typescript
    // `null` 혹은 `undefined`의 값을 가졌을 때 해당 값을 테스트해야 한다.
    const printName = (str: string | undefined) => {
      if (str === undefined) {
        // 아무런 동작을 하지 않음
      } else {
        console.log(str);
      }
    };
    ```

- `strictNullChecks: false` 경우

  - `null` 혹은 `undefined`의 값을 가져도 해당 값에 정상적으로 접근할 수 있다.
  - `null`과 `undefined` 값은 어떤 타입의 속성에도 할당될 수 있으며, null 검사가 없는 C#, Java의 동작 방식과 유사하다.

    ```typescript
    // null 검사의 부재는 버그의 주요 원인이 되며 해당 옵션을 설정하는 것을 권장한다.
    let name: string = null;
    ```

- **Non-null Assertion 연산자** - 명시적인 검사를 하지 않고 `null`, `undefined`를 제거할 수 있는 구문으로 `!` 연산자를 표현식 뒤에 붙여서 해당 값이 `null` 혹은 `undefined`가 아님을 단언한다.

  ```typescript
  const convertToUpperCase = (str: string | null) => {
    return str!.toUpperCase();
  };
  ```

<br>

<br>

## Object Types

> 💭 구조적 타입 시스템 vs. 명목적 타입 시스템을 알아보자.

JavaScript에서 데이터를 그룹화하고 전달하는 기본적인 방법은 객체를 통해서이다. TypeScript에서는 이러한 객체를 객체 타입(object types)으로 표현하며, 익명, 인터페이스, 타입 별칭으로 정의할 수 있다.

```typescript
// 1. 익명
function greet(person: { name: string; age: number }) {
  return 'Hello ' + person.name;
}

// 2. 인터페이스
interface Person {
  name: string;
  age: number;
}

function greet(person: Person) {
  return 'Hello ' + person.name;
}

// 3. 타입 별칭
type Person = {
  name: string;
  age: number;
};

function greet(person: Person) {
  return 'Hello ' + person.name;
}
```

<br>

객체 타입은 프로퍼티와 각 프로퍼티 타입을 나열한다. 각 프로퍼티 타입 표기는 선택 사항이며, 타입을 지정하지 않으면 `any`로 간주한다.

```typescript
const person: {
  name: string;
  age: number;
  hobbies: string[];
} = {
  name: '최개발',
  age: 28,
  hobbies: ['Game', 'Swimming'],
};
```

<br>

### Property Modifiers(속성 수정자)

객체 타입에서 각 속성은 타입, 속성의 선택적(optional) 여부, 속성의 쓰기 가능(writable) 여부를 지정할 수 있다.

<br>

#### Optional Properties(선택적 속성)

특정 속성이 설정될 수도 있고 아닐 수도 있는 객체를 다룰 때가 있다. 이런 경우, 해당 속성 이름 끝에 `?`를 추가하여 선택적 속성으로 표시할 수 있다.

```typescript
interface IName {
  first: string;
  last?: string;
}

function printName(name: IName) {
  // ...
}

printName({ last: '최' }); // ❌
printName({ first: '개발' }); // ⭕️
printName({ first: '개발', last: '최' }); // ⭕️
```

선택적 속성을 읽을 수도 있다. `strictNullChecks`가 설정된 경우 TypeScript에서는 해당 속성이 잠재적으로 `undefined`일 수 있다고 알려준다.

```typescript
function printName(name: IName) {
  // (property) IName.first: string
  let firstName = name.first;
  // (property) IName.last?: string | undefined
  let lastName = name.last;
}
```

JavaScript에서는 속성이 설정된 적이 없더라도 접근이 가능하며 `undefined` 값을 제공한다. `undefined`는 아래와 같은 방식으로 처리가 가능하다.

```typescript
// 1. 삼항 연산자 기본값 처리
function printName(name: IName) {
  let firstName = name.first;
  let lastName = name.last === undefined ? '' : name.last;
}

// 2. Default Parameter(매개변수 기본값)
// ➡️ 매개변수 구조 분해 패턴을 사용하고 last에 기본값 제공
// ➡️ last가 printName 본문 내에서는 확실히 존재하고 호출하는 쪽에서는 선택적으로 제공할 수 있음
function printName({ first, last = '최' }: IName) {
  console.log(first, last);
}
```

<br>

#### readonly Properties

TypeScript에서 값이 수정되면 안되는 속성은 `readonly`로 표시할 수 있다. `readonly`로 표시된 속성은 런타임 동작을 변경하진 않지만, 타입 검사 중에 쓰기가 불가능하다.

```typescript
interface User {
  readonly id: number;
  name: string;
  age: number;
}

const user: User = { id: 1, name: '최개발', age: 28 };

function printUserName(user: User) {
  console.log(user.name); // 읽기 가능

  // ❌ Cannot assign to 'id' because it is a read-only property.
  user.id = 2; // 재할당 불가
}
```

<br>

하지만 `readonly` 속성이 완전히 불변함을 의미하진 않는다. 내부 내용을 변경할 수 없다는 뜻은 아니며, 속성 자체를 다시 쓸 수 없다는 의미이다. 즉, `readonly`로 표시한 속성 자체의 재할당만 막을 뿐이지 속성이 가리키는 객체의 내부의 값들은 자유롭게 변경할 수 있다.

```typescript
interface Book {
  readonly author: { name: string; nationality: string };
  title: string;
}

function updateAuthorInfo(book: Book) {
  console.log(`작가: ${book.author.name}`);
  // book.author 속성의 객체 내부 값은 업데이트가 가능
  book.author.name = '최개발';
  book.author.nationality = '대한민국';
}

function changeAuthor(book: Book) {
  // book의 author 속성 자체에는 재할당 불가
  book.author = {
    // ❌ Cannot assign to 'author' because it is a read-only property.
    name: '김작가',
    nationality: '대한민국',
  };
}
```

<br>

#### Index Signatures

타입의 모든 속성 이름을 미리 알 수 없지만, 값의 형태를 알고 있는 경우가 있다. 해당 경우 인덱스 시그니처를 사용하여 미리 정의되지 않은 속성들의 타입을 지정할 때 사용한다. 즉, 객체에 동적으로 속성을 추가할 수 있게 해주는 문법이다.

```typescript
interface 인터페이스명 {
  [키이름: 키타입]: 값타입;
}
```

키 타입으로는 `string`, `number`, `symbol`, 템플릿 문자열 패턴의 타입만 가능하다. 문자열 키를 사용하는 전화번호부 같은 객체를 생성할 때 아래와 같이 사용할 수 있다.

```typescript
interface PhoneBook {
  [name: string]: string;
}

const phoneBook: PhoneBook = {
  철수: '010-1234-1234',
  영희: '010-1234-5678',
  민수: '010-8765-4321',
};

phoneBook['홍길동'] = '010-1111-2222'; // OK
```

<br>

여러 타입의 인덱스 시그니처를 사용할 수도 있다. `number`와 `string` 인덱서를 사용할 때 주의할 점은 `number` 인덱서에서 반환되는 타입이 `string` 인덱서에서 반환되는 타입의 서브타입이어야 한다. 이는 JavaScript가 `number`로 인덱싱할 때 실제로는 객체에 인덱싱하기 전에 `string`으로 변환하기 때문이다. 즉, `100`으로 인덱싱하는 것은 `"100"`으로 인덱싱하는 것과 같은 의미이다.

```javascript
const obj = {};
obj[100] = '숫자 인덱스 사용';
console.log(obj['100']); // 출력 결과: 숫자 인덱스 사용
console.log(obj[100]); // 출력 결과: 숫자 인덱스 사용
```

<br>

`number` 인덱싱이 `string` 인덱싱으로 자동 변환되는 JavaScript 동작 때문에 TypeScript에서는 `number` 인덱서의 반환타입은 `string` 인덱서의 반환 타입의 서브타입이어야 한다는 규칙을 강제하고 있다.

```typescript
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

interface NotOkay {
  [x: number]: Animal;
  // 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.
  [x: string]: Dog;
}
```

`NotOkay` 인터페이스에서 에러가 발생하는 이유는 아래와 같이 타입이 변환되면서 타입에 모순이 발생하기 때문이다.

```typescript
interface NotOkay {
  [x: number]: Animal;
  [x: string]: Dog;
}

const notOkay: NotOkay = /* ... */;
const result1 = notOkay[0]; // Animal 타입
const result2 = notOkay['0']; // Dog 타입
// 숫자 인덱서가 문자열 인덱서로 변환되면 Animal ➡️ Dog로 변환되는건데 Animal은 Dog로 취급할 수 없음

const myCat: Animal = { name: '냥이' };
const myDog: Dog = myCat; // ❌ Animal은 Dog로 취급 불가
```

반대로 `string` 인덱서의 반환 타입이 상위 타입인 경우는 에러가 발생하지 않는다. 위 예시에서 Dog는 Animal로 취급할 수 있기 때문이다.

```typescript
interface Okay {
  [x: number]: Dog;
  [x: string]: Animal;
}

const okay: Okay = /* ... */;
const result1 = okay[0]; // Dog 타입
const result2 = okay['0']; // Animal 타입

const myDog: Dog = { name: "바둑이", breed: "진돗개" };
const myAnimal: Animal = myDog;
```

<br>

> 💭 인덱스 시그니처는 명시적 속성과 반환타입이 일치해야한다.

추가로 문자열 인덱스 시그니처의 경우 dictionary 패턴을 표현하는 대표적인 방법인데 모든 속성이 반환 타입과 일치하도록 강제한다. 다음 예시에서 `name` 속성의 반환 타입이 인덱스 반환 타입과 일치하지 않아서 타입 검사기에서 에러가 발생한다. 이는 문자열 인덱스 `obj.name` 속성에 접근할 때 `obj['name']`과 같은데 인덱스 타입과 일치하지 않아서 에러가 발생한다.

```typescript
interface NumberDictionary {
  [index: string]: number;

  length: number; // ⭕️
  name: string;
  // Property 'name' of type 'string' is not assignable to 'string' index type 'number'.
}
```

만약 인덱스 시그니처가 속성 타입들의 유니온이라면 다른 타입의 속성들도 허용된다.

```typescript
interface NumberOrStringDictionary {
  [index: string]: number | string;
  length: number; // ⭕️
  name: string; // ⭕️
}
```

<br>

마지막으로 인덱스에 대한 할당을 방지하기 위해서 인덱스 시그니처를 `readonly`로 선언할 수 있다.

```typescript
interface ReadonlyStringArray {
  readonly [index: number]: string;
}

let myArray: ReadonlyStringArray = getReadOnlyStringArray();
myArray[2] = 'Mallory';
// Index signature in type 'ReadonlyStringArray' only permits reading.
```

이는 불변 설정 객체나 React에서 props를 직접 수정하지 못하도록 보호할 때와 같은 상황에서 유용하게 사용할 수 있다.

```typescript
// 불변 설정 객체
interface AppConfig {
  readonly [key: string]: string | number | boolean;
}

const config: AppConfig = {
  apiUrl: 'https://api.example.com',
  timeout: 3000,
  debugMode: false,
};

// 읽기는 가능
console.log(config.apiUrl); // ✅ OK

// 수정은 불가능
config.apiUrl = 'https://new-api.com'; // ❌ 에러!
config.newSetting = true; // ❌ 에러!
```

```typescript
interface ReadonlyProps {
  readonly [prop: string]: any;
}

// 컴포넌트가 props를 직접 수정하지 못하도록 보호
function MyComponent(props: ReadonlyProps) {
  // props.title = "new title";  // ❌ props 수정 불가

  // 대신 state나 새 변수 사용
  const [title, setTitle] = useState(props.title);
}
```

<br>

### Excess Property Checks(초과 속성 검사)

> 💬 추가 속성이 있을 때에만 발생하며, 객체 리터럴을 직접 할당할 때에만 적용되고 간접 할당시 발생하지 않는다.

<br>

초과 속성 검사는 객체 리터럴을 사용할 때 발생하는 특별한 타입 검사 메커니즘이다. 객체 리터럴이 특정 타입에 직접 할당될 때만 발생하는 엄격한 검사로 잘못된 속성명을 사용하는 것을 방지하기 위함으로 정의되지 않은 속성을 감지한다.

```typescript
interface Person {
  name: string;
  age: number;
  hobby?: string;
}

const person1: Person = {
  name: '최개발',
  age: 28,
  hobbi: '수영', // ❌ Object literal may only specify known properties, but 'hobbi' does not exist in type 'Person'. Did you mean to write 'hobby'?
};

const person2: Person = {
  name: '최개발',
  age: 28,
  hobby: '수영',
};
```

일반적인 JavaScript에서 변수에 객체를 할당할 때에 속성명을 잘못 입력하더라도 런타임 이전에 에러를 발생시키지 않는다. 하지만 TypeScript에서는 객체 리터럴이 다른 변수에 할당되거나 인수로 전달될 때 초과 속성 검사를 받는다. 객체 리터럴이 해당 타입에 없는 속성을 가지고 있을 경우 에러가 발생한다.

<br>

#### 초과 속성 검사가 발생하는 경우

##### 1. 직접 할당

```typescript
interface Person {
  name: string;
  age: number;
  hobby?: string;
}

const person: Person = {
  name: '최개발',
  age: 28,
  hobbi: '수영', // ❌ 오타
};
```

<br>

##### 2. 함수 인수로 전달

```typescript
function createPerson(person: Person) {
  // ...
}

createPerson({
  name: '최개발',
  age: 28,
  hobbi: '수영', // ❌ 오타
});
```

<br>

##### 3. 함수 반환값으로 사용

```typescript
function createPerson(): Person {
  return {
    name: '최개발',
    age: 28,
    hobbi: '수영', // ❌ 오타
  };
}
```

<br>

#### 초과 속성 검사가 발생하지 않는 경우

##### 1. 변수 간접 할당

> 💬 필수 속성을 오타내서 누락된 경우 '타입 호환성 검사'에서 에러를 발생시키는데 이는 초과 속성 검사와는 별개 내용이다.

```typescript
interface Person {
  name: string;
  age: number;
  hobby?: string;
}

const tempPerson = {
  name: '최개발',
  age: 28,
  hobbi: '수영',
};

const person: Person = tempPerson; // ✅ 정상 작동
```

<br>

##### 2. 타입 호환성 확인

```typescript
interface Person {
  name: string;
  age: number;
  hobby?: string;
}

const tempPerson = { name: '최개발', gender: '남자' };
const person: Person = tempPerson; // ✅ 정상 작동 (구조적 타이핑)
```

<br>

#### 초과 속성 검사 우회 방법

##### 1. 타입 단언

```typescript
interface Person {
  name: string;
  age: number;
  hobby?: string;
}

const person = {
  name: '최개발',
  age: 28,
  gender: '남자', // 추가 속성
} as Person; // ✅ 추가 속성이 있지만 타입 단언으로 우회
```

<br>

##### 2. 인덱스 시그니처

객체가 추가 속성을 가질것이라 확신하면 타입 단언보다 인덱스 시그니처를 추가하는게 더 나은 접근 방법일 수 있다. `Person`이 `name`과 `age` 속성 외에 다른 속성을 얼마든지 가질 수 있다면 다음과 같이 정의할 수 있다.

```typescript
interface Person {
  name: string;
  age: number;
  hobby?: string;
  [key: string]: any; // 추가 속성 허용
}

const config: Person = {
  name: '최개발',
  age: 28,
  gender: '수영', // ✅  추가 속성 허용
};
```

<br>

##### 3. 변수를 통한 간접 할당

검사를 우회하는 마지막 방법은 객체를 다른 변수에 할당하는 것이다. `tempPerson`를 할당하는 것은 초과 속성 검사를 거치지 않으므로 컴파일러 오류가 발생하지 않는다.

```typescript
const tempPerson = {
  name: '최개발',
  age: 28,
  gender: '남자',
};

const person: Person = tempPerson; // ✅ 초과 속성 검사 우회
```

<br>

### Extending Types(타입 확장)

타입 확장은 기존 타입을 기반으로 새로운 타입을 만드는 방법이다. 코드 재사용성을 높이고 타입간의 관계를 명확히 표현할 수 있다.

```typescript
interface 기본타입 {
  // 기본 속성을 작성
}

interface 확장타입 extends 기본타입 {
  // 기본 속성을 제외한 추가 속성을 작성
}
```

<br>

예시는 아래와 같다.

```typescript
interface MenuItem {
  name: string;
  price: number;
}

interface Burger extends MenuItem {
  patty: boolean;
  bacon: boolean;
  cheese: boolean;
}

const quarterPounderWithCheese: Burger = {
  name: '쿼터파운더치즈',
  price: 5500,
  patty: true,
  bacon: false,
  cheese: true,
};
```

<br>

#### 다중 상속과 중첩 확장

하나의 인터페이스가 여러 인터페이스를 동시에 확장할 수 있다. 또한 확장된 인터페이스를 다시 확장할 수도 있다.

```typescript
interface MenuItem {
  name: string;
  price: number;
}

interface Burger extends MenuItem {
  patty: boolean;
  bacon: boolean;
  cheese: boolean;
}

interface Side {
  fries: boolean;
  drink: boolean;
}

interface ExtraValueMeal extends Burger, Side {
  discount: number;
}

const quarterPounderWithCheeseMeal = {
  name: '쿼터파운더치즈세트',
  price: 7600,
  patty: true,
  bacon: false,
  cheese: true,
  fries: true,
  drink: true,
  discount: 2300,
};
```

<br>

#### Override(속성 재정의)

타입을 확장할 때 기존 속성의 타입을 `extends`를 사용하여 구체적으로 재정의할 수 있다.

```typescript
interface Drink {
  name: string;
  size: string | number;
}

interface Soda extends Drink {
  name: '콜라' | '사이다' | '환타';
  size: 'M' | 'L';
  carbonated: boolean;
  ice: boolean;
}

const coke: Soda = {
  name: '콜라',
  size: 'L',
  carbonated: true,
  ice: true,
};
```

<br>

#### Intersection Types(교차 타입)

> `&` 연산자를 사용하여 객체 타입을 결합하는 타입. `interface`와 `type`에서 사용이 가능하다.

`interface`를 사용하면 다른 타입들을 확장하여 새로운 타입을 만들 수 있었다. TypeScript는 `&` 연산자를 사용하여 주로 기존 객체 타입들을 결합하는 데 사용하는 intersection type이라는 구조를 제공한다.

```typescript
interface Burger {
  patty: boolean;
  bacon: boolean;
  cheese: boolean;
}

interface Fries {
  salt: boolean;
}

type BurgerAndFries = Burger & Fries;
```

`Burger`와 `Fries`을 교차하여 두 인터페이스의 모든 속성을 가지는 새로운 타입을 생성하였다.

```typescript
// ✅  정상
function orderMeal(meal: Burger & Fries) {
  console.log(meal.patty);
  console.log(meal.bacon);
  console.log(meal.cheese);
  console.log(meal.salt);
}
```

```typescript
// ❌ 오류(salt 오타)
function orderMeal2(meal: Burger & Fries) {
  console.log(meal.patty);
  console.log(meal.bacon);
  console.log(meal.cheese);
  console.log(meal.sat); // Property 'sat' does not exist on type 'Burger & Fries'. Did you mean 'salt'?(2551)
}
```

<br>

Type alias으로만 계속하여 결합이 가능하다.

```typescript
type BasicPizza = {
  name: string;
  cheese: boolean;
};

type ToppedPizza = BasicPizza & {
  toppings: string[];
  crustType: string;
};

type PremiumPizza = BasicPizza &
  ToppedPizza & {
    price: number;
    deliveryTeime: number;
  };
```

<br>

#### Interface Extension vs. Intersection

앞서 비슷한 두 가지 타입 결합 방법으로 interface의 `extends`와 intersection type을 살펴보았다. 비슷하지만 다른 결합 방식의 차이점은 **충돌이 처리되는 방식**이다. 이 차이점은 일반적으로 interface `extends`와 intersection type 중 하나를 선택하게 되는 이유가 된다.

동일한 속성 이름으로 interface가 정의되면, TypeScript는 속성들이 호환되는 경우 병합하려고 한다. 속성 이름이 같으나 다른 타입이어서 속성이 호환되지 않는 경우 오류가 발생한다.

Intersection type의 경우 다른 타입을 가진 속성들이 자동으로 병합된다. TypeScript는 해당 속성이 두 타입을 동시에 만족하기를 기대하며 예상치 못한 결과가 초래된다. 예를 들어서 아래 코드는 속성들이 호환되지 않기 때문에 에러가 발생한다.

```typescript
interface Burger {
  patty: boolean;
}

interface Burger {
  patty: number;
}
```

<br>

반면에 다음 코드는 컴파일 되지만 `never` 타입을 결과로 만든다.

```typescript
interface BigMac {
  patty: boolean;
}

interface QuarterPounder {
  patty: number;
}

type McCombo = BigMac & QuarterPounder;

declare const combo: McCombo;
combo.patty; // (property) patty: never
// ❌ Property 'patty' does not exist on type 'never'. The intersection 'McCombo' was reduced to 'never' because property 'patty' has conflicting types in some constituents.(2339)
```

위의 경우 `McCombo`의 `patty` 속성은 `boolean`이면서 `number`이어야 하는데 이는 불가능하므로 해당 속성은 `never`타입이 된다.

<br>

### Generic Object Types

`Box`타입이 어떤 값이든 담을 수 있다고 했을 때, `any`로 지정한다면 작동은 하지만 에러로 이어질 수 있다.

```typescript
interface Box {
  contents: any;
}
```

<br>

대신에 `unknown`을 사용할 수 있지만, `contents`의 타입을 알고 있는 경우 타입 가드를 사용하거나 오류가 발생하기 쉬운 타입 단언을 사용해야 한다.

```typescript
interface Box {
  contents: unknown;
}

let x: Box = {
  contents: 'Hello, world',
};

// 타입 가드
if (typeof x.contents === 'string') {
  console.log(x.contents.toLowerCase());
}

// 타입 단언
console.log((x.contents as string).toLowerCase());
```

<br>

안전한 타입 접근법 중 하나는 각 `contents` 속성에 대해서 서로 다른 `Box` 타입을 만들어 놓는 것이다.

```typescript
interface NumberBox {
  contents: number;
}

interface StringBox {
  contents: string;
}

interface BooleanBox {
  contents: boolean;
}
```

<br>

하지만 서로다른 `Box` 타입을 만든다는 것은 이러한 타입을 다루기 위하여 서로 다른 함수나 함수 오버로드를 만들어야 한다는 의미이다. 이는 너무 많은 보일러플레이트를 유발하며 나중에 새로운 타입들과 오버로드를 도입해야 할 수 있다.

```typescript
function setContents(box: StringBox, newContents: string): void;
function setContents(box: NumberBox, newContents: number): void;
function setContents(box: BooleanBox, newContents: boolean): void;
function setContents(box: { contents: any }, newContents: any) {
  box.contents = newContents;
}
```

위와 같이 작성하는 대신에 type parameter를 선언하는 제네릭 `Box` 타입을 만들 수 있다. 추후 `Box` 타입을 사용할 때, `Type` 자리에 타입 인수를 제공해야 한다.

```typescript
interface Box<Type> {
  contents: Type;
}

let box: Box<string>;
```

<br>

`Type`은 다른 타입으로 대체될 placeholder이다. TypeScript가 `Box<string>`을 보면, `Box<Type>`에서 `Type`의 모든 인스턴스를 `string`으로 바꾸고 `{ contents: string }`과 같은 것으로 작업하게 된다.

```typescript
interface Box<Type> {
  contents: Type;
}

interface StringBox {
  contents: string;
}

let boxA: Box<string> = { contents: 'hello' };
boxA.contents; // (property) Box<string>.contents: string

let boxB: StringBox = { contents: 'world' };
boxB.contents; // (property) StringBox.contents: string
```

<br>

`Box`는 `Type`이 어떤 타입으로든 대체될 수 있다는 점에서 재사용이 가능하다. 새로운 타입을 위한 박스가 필요할 때 새로운 `Box` 타입을 선언할 필요가 없어진다. 마찬가지로 제네릭 함수를 사용하여 오버로드를 피할 수 있다.

```typescript
function setContents<Type>(box: Box<Type>, newContents: Type) {
  box.contents = newContents;
}
```

<br>

#### The Array Types

제네릭 객체 타입들은 담고 있는 속성들과 독립적으로 작동한다. 즉, 작성되어 있는 코드들이 숫자형, 문자형 등의 타입을 전혀 신경쓰지 않고 똑같이 작동함을 의미한다. 타입에 따라서 다른 동작을 하지 않기에 새로운 타입마다 새로운 로직을 작성할 필요가 없다.

```typescript
let arr1: Array<number> = [1, 2, 3];
let arr2: Array<string> = ['a', 'b', 'c'];
let arr3: Array<{ name: string }> = [{ name: '최개발' }];

arr1.push(4); // [1, 2, 3, 4]
arr2.push('d'); // ['a', 'b', 'c', 'd']
arr3.push({ name: '심개발' }); // [{ name: '최개발' }, { name: '심개발' }]
```

<br>

위처럼 독립적으로 작동하는 일종의 컨테이너 타입과 같은 데이터 구조 방식으로 작동하는 것이 이상적인데, 이를 통해서 서로 다른 데이터 타입에 재사용이 가능하기 때문이다.

`Array`이 바로 위와 같은 방식을 나타낸다. `number[]`, `string[]`와 같이 타입을 작성했는데, 이는 실제로 `Array<number>`, `Array<string>`의 줄임표현이며, `Array` 자체도 제네릭 타입이다.

```typescript
interface Array<Type> {
  /**
   * 배열의 길이를 얻거나 설정합니다.
   */
  length: number;

  /**
   * 배열에서 마지막 요소를 제거하고 그것을 반환합니다.
   */
  pop(): Type | undefined;

  /**
   * 배열에 새로운 요소들을 추가하고, 배열의 새로운 길이를 반환합니다.
   */
  push(...items: Type[]): number;

  // ...
}
```

<br>

#### The ReadonlyArray Type

`ReadonlyArray`는 변경되어서는 안 되는 배열인 타입이다. `ReadonlyArray`를 반환하는 함수를 보면, 내용을 변경하지 말라는 뜻임을 알 수 있다. 또한 `ReadonlyArray`를 받는 함수를 보면, 해당 함수가 내용을 변경할 것이라는 걱정 없이 어떤 배열이든 함수에 전달할 수 있다.

`Array`와 다르게 `ReadonlyArray`는 생성자가 없다.

```typescript
new ReadonlyArray('red', 'blue', 'green');
// 'ReadonlyArray' only refers to a type, but is being used as a value here.
```

일반적인 `Array`를 `ReadonlyArray`에 할당할 수 있다.

```typescript
const roArray: ReadonlyArray<string> = ['red', 'blue', 'green'];
```

<br>

TypeScript가 `Array<Type>`에 대해 `Type[]`라는 단축 문법을 제공하는 것처럼, `ReadonlyArray<Type>`에 대해서도 `readonly Type[]`과 같이 단축 문법을 제공한다.

```typescript
function doStuff(values: readonly string[]) {
  const copy = values.slice();
  console.log(`Copy: ${copy}`);

  values.push('hello!');
  // Property 'push' does not exist on type 'readonly string[]'.
}
```

<br>

`readonly`와 달리 일반적인 `Array`와 `ReadonlyArray` 사이의 할당 가능성은 양방향이 아니다.

```typescript
let x: readonly string[] = [];
let y: string[] = [];

x = y; // ✅
y = x; // ❌ The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.
```

<br>

#### Tuple Types

튜플 타입은 정확하게 몇 개의 요소를 포함하고 있는지, 특정 인덱스에 어떤 타입을 포함하고 있는지를 아는 Array 타입이다.

```typescript
type StringNumberPair = [string, number];
```

위 `StringNumberPair`의 경우 `string`과 `number`의 튜플 타입이다. 0번 인덱스에 `string`을 포함하고 1번 인덱스에 `number`를 포함하는 배열을 의미한다.

<br>

```typescript
function doSomething(pair: [string, number]) {
  const a = pair[0]; // const a: string
  const b = pair[1]; // const b: number
  // ...
}

doSomething(['hello', 30]);
```

만약 요소의 개수를 넘어서 인덱스에 접근하려고 할 경우 에러가 발생한다.

```typescript
function doSomething(pair: [string, number]) {
  //...
  const c = pair[2];
  // Tuple type '[string, number]' of length '2' has no element at index '2'.
}
```

<br>

나머지 요소를 사용하여 아래와 같이 표현이 가능하다.

```typescript
type StringNumberBooleans = [string, number, ...boolean[]];
type StringBooleansNumber = [string, ...boolean[], number];
type BooleansStringNumber = [...boolean[], string, number];
```

- `StringNumberBooleans`는 처음 두 요소가 각각 `string`, `number`이지만, 그 다음에 임의의 개수의 `boolean`이 올 수 있는 튜플이다.
- `StringBooleanNumber`는 첫 번째 요소가 `string`이고 그 다음에 임의의 개수의 `boolean`이 오고 `number`로 끝나는 튜플이다.
- `BooleanStringNumber`는 시작 요소들이 임의의 개수 `boolean`이고 `string` 다음 `number`로 끝나는 튜플이다.

<br>

#### `readonly` Tuple Types

튜플 타입은 배열 단축 문법과 마찬가지로 `readonly`를 붙여서 지정할 수 있다. `readonly` 튜플의 어떤 속성에도 쓰기가 허용되지 않는다.

```typescript
function doSomething(pair: readonly [string, number]) {
  // ...
  pair[0] = 'hello'; // Cannot assign to '0' because it is a read-only property.
}
```

<br>

## Arrays

`Type[]`와 같은 구문으로 `number[]`, `string[]`, `boolean[]`와 같이 사용한다. 제네릭의 `Array<Type>`와 같은 의미이며, 튜플의 `[Type]`와는 다른 의미이다.

```typescript
// number[] - number 타입만 허용
const nums: number[] = [1, 2, 3];

// string[] - string 타입만 허용
const strs: string[] = ['가', '나', '다'];

// boolean[] - boolean 타입만 허용
const bools: boolean[] = [true, false];

// any[] - 모든 타입 허용
const anys: any[] = [1, '가', true];

// 명시한 특정 타입 허용
const specific: (number | string)[] = [1, '가'];

// Type[][] - 다차원 배열 정의
const numMatrix: number[][] = [
  [1, 2, 3], // number[]
  [4, 5, 6], // number[]
];
const unionMatrix: (string | number)[][] = [
  ['개', 1, 2], // (string | number)[]
  ['발', 3, 4], // (string | number)[]
];
const unionMatrix2: (string[] | number[])[] = [
  ['개', '발'], // string[]
  [1, 2], // number[]
];
```

<br>

## Tuple

길이와 타입이 고정된 JavaScript의 배열과 달리 각 인덱스 위치에 타입을 지정하여 고정된 길이와 순서를 가지는 배열을 정의할 수 있다. 대괄호 내에 `,`를 구분자로 사용하여 타입을 나열하여 사용한다.

```typescript
let person: [string, number] = ['최개발', 28];
```

<br>

정의한 타입과 일치하지 않는 타입의 요소가 들어가거나 길이가 일치하지 않을 경우 아래와 같은 에러가 발생한다.

```typescript
// Type 'string' is not assignable to type 'number'.
let person: [string, number] = ['최개발', '프론트엔드'];

// Type '[string, number, boolean]' is not assignable to type '[string, number]'.
// Source has 3 element(s) but target allows only 2.
person: [string, number] = ['최개발', 28, true];
```

<br>

정의한 타입과 일치하는 경우 재할당도 가능하다.

```typescript
person = ['김개발', 24]; // ✅ [string, number]
person = [26, '이개발']; // ❌ [number, string]
```

<br>

Tuple은 배열 메서드(e.g., `push`, `pop`)가 허용되기에 에러가 발생하지 않는다. 하지만 배열 메서드를 사용하여 요소를 추가할 때, 정의한 타입과 일치하지 않을 경우 에러가 발생한다.

```typescript
// ✅ 정의한 타입과 일치할 경우 배열 메서드 허용
person.push('김개발'); // ['최개발', 28, '김개발']

// ❌ 정의한 타입과 일치하지 않을 경우 에러 발생
person.push(true); // // Argument of type 'boolean' is not assignable to parameter of type 'string | number'.
```

배열 메서드가 허용되는 이유는 Tuple이 JavaScript의 배열을 확장한 형태이기 때문이다. 실제로 `.ts` 파일로 작성된 내용을 컴파일한 결과를 확인해보면 JavaScript의 배열로 변환되는 것을 확인할 수 있다. 즉 Tuple은 배열과 동일하게 취급되어 배열 메서드가 문제없이 적용되는 것이다. 하지만 배열 메서드를 사용할 경우 Tuple로 지정한 길이를 초과하여 타입 안정성이 깨지는 문제가 발생할 수 있으므로 주의해야 한다.

<br>

Tuple은 배열의 인덱스 위치에 따라서 넣어야 하는 값들이 이미 정해져 있어서 순서를 지켜야할 때 사용한다.

```typescript
// 1. useState 훅
const [count, setCount] = useState<number>(0); // [number, Dispatch<SetStateAction<number>>]

// 2. 폼 필드 정의
const loginForm: [string, string, boolean][] = [
  ['사용자명', '', true],
  ['비밀번호', '', true],
  ['이메일', '', false],
];
```

<br>

## Functions

TypeScript는 함수의 입력 및 출력 타입을 지정할 수 있다. 익명 함수의 경우 함수가 어떻게 호출되는지 알아내고 매개 변수에 자동으로 타입을 부여한다. 아래 코드를 살펴보면 함수에 대한 문맥적 타이핑(contextual typing)으로 매개변수 `name`은 `string`으로 타입 추론된다.

<img width="353" alt="image" src="https://user-images.githubusercontent.com/96946274/229846050-82081996-77c2-4022-9da8-e8196b70a562.png">

<br>

```typescript
// 1. 매개변수 타입 표기
const greet = (name: string) => {
  console.log('Hello, ' + name);
};
greet(42); // ❌ 런타임 에러 발생

// 2. 반환 타입 표기
// ➡️ 반환 타입을 추론하기 때문에 일반적으로 필요하지 않지만, 개인 선호도에 따라서 문서화 목적과 우발적 변경 방지를 위해 작성하곤 한다.
const getNumber = (): number => {
  return 28;
};

// 3. Promise 반환 함수
async function getFavoriteNumber(): Promise<number> {
  return 30;
}

// 4. Function 타입 표기
const add = (num1: number, num2: number) => {
  return num1 + num2;
};
let combineValues: Function;
combineValues = add;

// 어떤 타입의 매개변수를 받고, 어떤 타입의 값을 반환할지 명확하게 설정할 수 있다.
let addValues: (a: number, b: number) => number;

// callback 함수 만들어보기
const addHandle = (num1: number, num2: number, cb: (num: number) => void) => {
  const result = num1 + num2;
  cb(result);
};
addHandle(1, 2, (result) => {
  console.log(result);
}); // 3
```

<br>

## Literal Types

구체적인 문자열, 숫자 값을 가지는 타입이다. JavaScript에서 `var`, `let`은 변수의 값 변경을 허용하고 `const`는 허용하지 않는다. TypeScript에서는 이러한 차이가 리터럴 타입 생성에 반영된다.

changingString은 어떤 문자열을 나타낼 수 있기에 TypeScript는 타입 시스템에서 `let changingString: string`와 같이 `string`으로 추론한다.

```typescript
// let changingString: string
let changingString = 'Hello World';
changingString = '헬로 월드';
```

<br>

constantString은 단 하나의 가능한 문자열만 나타낼 수 있으므로 리터럴 타입으로 `const constantString: "Hello World"`와 같이 추론된다. 이처럼 TypeScript는 알아서 리터럴 타입으로 추론하므로 `let`으로 변수를 선언하여 리터럴 타입을 표기할 이유는 없다.

```typescript
const constantString = 'Hello World';
```

<br>

오직 하나의 값만을 가질 수 있는 변수는 유용하지 않지만 리터럴을 유니온(union)으로 조합하면 훨씬 유용한 개념을 표현할 수 있다. 예시로 `boolean`타입은 실제로는 리터럴 타입으로 `true | false`의 type aliase이다.

```typescript
// const로 선언한 변수는 리터럴 타입으로 추론된다.
const num = 1; // const num: 1

// 리터럴 타입으로 지정한 값만 허용된다.
const printName = (username: string, alignment: 'left' | 'center' | 'right') => {
  // ...
};

printName('최개발', 'left'); // ⭕️
printName('심개발', 'centre'); // ❌ Argument of type '"centre"' is not assignable to parameter of type '"left" | "center" | "right"'.
```

<br>

문자열, 숫자형과 같은 원시 자료형 리터럴 타입 외에도 객체를 표시하는 리터럴 타입이 있다. 주의할 점은 함수 리터럴 타입 반환값 표기는 `:` 대신 `=>`를 사용한다. 함수 리터럴 타입에 매개변수와 반환값의 타입을 표기하면 실제값 타입 표기는 생략이 가능하다.

```typescript
// 객체 리터럴 타입
const obj: { name: '최개발' } = { name: '최개발' };

// 배열 리터럴 타입
const arr: [1, 2, 'three'] = [1, 2, 'three'];

// 함수 리터럴 타입
const func: (amount: number, unit: string) => string = (amount, unit) => amount + unit;
```

<br>

### Literal Inference

객체 리터럴 타입을 사용할 때 조심할 점이 있다. TypeScript는 의도한 것보다 리터럴 타입을 부정확하게 추론한다.

```typescript
const obj = { name: '최개발' }; // const obj: { name: string }
const arr = [1, 2, 'three']; // const arr: (string | number)[]
```

JavaScript의 객체는 `const`로 선언한 변수여도 수정할 수 있으므로, TypeScript는 수정 가능성을 염두하여 타입을 넓게 추론한다. 값이 변하지 않는 것이 확실하면 `as const`라는 접미사를 붙이면 된다.

```typescript
const obj = { name: '최개발' } as const; // const obj: { readonly name: '최개발' }
const arr = [1, 2, 'three'] as const; // const arr: readonly [1, 2, 'three']
obj.name = '심개발'; // ❌ Cannot assign to 'name' because it is a read-only property.
arr.push(4); // ❌ Property 'push' does not exist on type 'readonly [1, 2, "three"]'.
```

타입이 고정되어 추론되는데 `readonly` 수식어가 붙는다. 해당 수식어가 붙으면 값은 변경할 수 없다. JavaScript라면 객체와 배열의 변경이 문제없이 진행되지만, TypeScript에서는 에러가 발생한다. JavaScript에서는 실수로 객체를 변경하여 에러가 발생하는 일이 생기는데 TypeScript에서는 이를 엄격하게 통제할 수 있다.

<br>

이는 문자열에서도 동일하게 적용된다.

```typescript
declare function handleRequest(url: string, method: 'GET' | 'POST'): void;

const req = { url: 'https://example.com', method: 'GET' };
handleRequest(req.url, req.method); // ❌ Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.
```

`req.method`는 `"GET"`이 아닌 `string`으로 추론된다. `req` 객체 생성 시점과 `handleRequest` 함수 호출 시점 사이에 코드가 실행되어 `req.method`에 새로운 문자열이 할당될 수 있기 때문에 오류가 있다고 판단한다. 마찬가지로 타입 단언(type assertion)이나 `as const`를 사용하여 전체 객체를 리터럴 타입으로 변환할 수 있다.

```typescript
// 타입 단언 방법 1
// ➡️ `req.method`가 항상 리터럴 타입 "GET"을 갖도록 의도했다는 의미로 생성 후 다른 문자열이 해당 필드에 할당하는 것을 방지한다.
const req = { url: 'https://example.com', method: 'GET' as 'GET' };

// 타입 단언 방법 2
// ➡️ `req.method`가 `"GET"` 값을 가지고 있다는 것을 알고 있다는 의미이다.
handleRequest(req.url, req.method as 'GET');

// 전체 객체 리터럴 전환
const req = { url: 'https://example.com', method: 'GET' } as const;
handleRequest(req.url, req.method);
```

<br>

## `any`

TypeScript의 특별한 타입으로 특정 값이 타입 검사 오류를 발생시키지 않기를 원할 때마다 사용할 수 있다. 하지만 `any`는 TypeScript가 주는 장점인 타입 검사 시스템을 모두 우회하여 JavaScript를 쓰는 것과 같게 된다. 아래의 경우를 제외하고는 `any`를 사용하지 않는 것이 좋다.

- 특정 값으로 인하여 타입 검사 오류가 발생하는 것을 원하지 않는 경우 _(특정 코드가 문제 없음을 TypeScript에 확신시키기)_
- 어떤 값 혹은 데이터가 저장될지 알 수 없는 경우

```typescript
let anyType: any;

// 어느 값을 할당하여도 타입 에러가 발생하지 않는다.
anyType = 1;
anyType = '가';
anyType = true;
```

<br>

### `noImplicitAny`

보통의 경우 타입 검사를 받지 않는 `any`를 사용하고 싶지 않을 것이다. `any`를 에러로 표시하고 싶다면 **tsconfig.json**에 설정된 `noImplicitAny` 설정 값을 `true`로 설정한다.

<br>

### `unknown`

사용자가 어떤 값을 입력할지 모르는 경우 사용한다.

```typescript
let unknownUserInput: unknwon;
let userName: string;

// any와 비슷하게 어떤 타입이든 에러 없이 저장이 가능하다.
unknownUserInput = 1;
unknownUserInput = '가';

// string 타입의 변수에 unknown 타입 값을 할당하면 에러가 발생한다.
userName = unknownUserInput; // Type 'unknown' is not assignable to type 'string'.

// string 타입의 변수에 any 타입 값을 할당하면 에러가 발생하지 않는다.
let anyUserInput: any = 1;
userName = anyUserInput; // any는 타입확인을 수행하지 않음

// unknown을 다른 변수에 할당하고 싶을 때는 타입 검사를 진행하면 된다.
if (typeof unknownUserInput === 'string') userName = unknownUserInput;
```

<br>

#### void

값을 반환하지 않는 함수의 반환 값을 의미하며 `return`문이 없거나 명시적으로 값을 반환하지 않았을 때 추론되는 타입이다.

```typescript
// 타입 추론된 반환 값은 void이다.
const noop = () => {
  return;
};
```

<br>

#### Function Overloads

함수의 다양한 signature를 지원하는 기능으로 동일한 함수의 이름으로 다양한 매개변수 유형과 반환 유형을 처리할 수 있다. 함수 시그니처에 대한 명시적인 유형 선언을 제공할 수 있고, 함수 호출 시 매개변수와 반환 값의 타입을 명확하게 지정할 수 있다.

```typescript
type Combinable = number | string;

function add(x: Combinable, y: Combinable) {
  if (typeof x === 'string' || typeof y === 'string') {
    return x.toString() + y.toString();
  }
  return x + y;
}

const result = add('최개발', '코딩중'); // const result: string | number
result.split(' '); // Property 'split' does not exist on type 'string | number'. Property 'split' does not exist on type 'number'.

const result2 = add('최개발', '코딩중') as string;
result2.split(' ');
```

위 예시의 경우 string 타입 두 개를 입력했지만 `result` 변수의 타입은 여전히 `string`으로 추론되는 게 아니라 `string | number`임을 확인할 수 있다. 그래서 `.split()` 메서드를 사용하지 못하여 타입 단언을 통해서 해결했다. 함수 오버로드를 통해서 함수를 더 유연하게 작성할 수 있다.

```typescript
type Combinable = number | string;

function add(x: string, y: string): string;
function add(x: number, y: number): number;
function add(x: Combinable, y: Combinable) {
  if (typeof x === 'string' || typeof y === 'string') {
    return x.toString() + y.toString();
  }
  return x + y;
}

const result = add(1, 2); // const result: number
```

<br>

### Union Types

서로 다른 두 개 이상의 타입을 `|`로 구분하여 만들며, 각 타입을 멤버라고 부른다. Union 타입은 모든 멤버의 타입을 허용한다.

```typescript
let id: string | number;

id = 123;
id = '가나다';
id = true; // ERROR
```

Union 타입에 메서드를 사용하기 위해서는 모든 멤버에 유효한 작업이여야 한다.

```typescript
const printUpper = (str: string | string[]) => {
  console.log(str.toUpperCase());
  // Property 'toUpperCase' does not exist on type 'string | string[]'.
};

// typeof 타입 가드를 통해서 해결 가능하다(narrowing).
const printUpper = (strs: string | string[]) => {
  if (typeof strs === 'string') {
    console.log(strs.toUpperCase());
  } else {
    strs.forEach((str) => {
      console.log(str.toUpperCase());
    });
  }
};
```

<br>

### Type Aliases

별칭 앞에 `type` 키워드를 사용하여 같은 타입의 중복을 피하여 재사용하거나 타입에 이름을 붙이고 싶을 때 사용한다. Object 타입 별칭을 만들 때 주로 사용되며, Primitive, Union 등 모든 타입에도 별칭을 만들 수 있다.

```typescript
type Person = {
  name: string;
  age: number;
};

const greet = (person: Person) => {
  console.log(person.name + '은 ' + person.age + '살 입니다.');
};
greet({ name: '최개발', age: 28 }); // "최개발은 28살 입니다."
```

<br>

타입 별칭을 선언할 때에는 동일 스코프 내에서는 이름이 중복되면 에러가 발생한다.

```typescript
// ❌ Duplicate identifier 'Person'.
type Person = {
  name: string;
  age: number;
};

// ❌ Duplicate identifier 'Person'.
type Person = {};
```

<br>

### Interfaces

```typescript
interface Person {
  name: string;
  age: number;
}

const printPerson = (person: Person) => {
  console.log(person.name);
  console.log(person.age);
};
printPerson({ name: '최개발', age: 28 });
```

interface의 대부분 기능은 type alias에서도 가능하며 이름을 부여해주는 점이 동일하다. 차이점은 interface는 객체 타입에만 이름을 다는게 가능하지만, type alias는 모든 타입에 이름을 달 수 있다.

<img width="500" alt="image" src="https://user-images.githubusercontent.com/96946274/229854130-da06947b-7a2f-4334-ae7b-7261dcef25a9.png">

<br>

### Intersection Types

Interface를 사용하면 다른 유형에서 확장하여 새 유형을 만들 수 있다. TypeScript는 기존 객체 유형을 결합하는 데 교차 유형(Intersection types)라는 구조를 제공하며 `&` 연산자를 사용하여 정의된다.

```typescript
interface Colorful {
  color: string;
}
interface Circle {
  radius: number;
}

type ColorfulCircle = Colorful & Circle;
```

<br>

### Type Assertions

TypeScript가 추론한 타입보다 본인이 타입에 대한 정보를 더 정확히 아는 경우 타입 단언을 통해서 조금 더 구체적으로 명시할 수 있다. 보다 구체적이거나 덜 구체적인 타입으로 변환하는 것만 허용되며 숫자형을 문자형으로 assertion 하는 것은 불가능하다.

```typescript
// TypeScript는 document.getElementById는 HTMLElement 중 무언가 반환된다는 것만 알고있다.
// const myCanvas: HTMLElement | null로 타입 추론
const myCanvas = document.getElementById('main_canvas');

// type assertion
const myCanvas2 = document.getElementById('main_canvas') as HTMLCanvasElement;

// type assertion2
const myCanvas2 = <HTMLCanvasElement>document.getElementById('main_canvas');
```

<br>

### never

일반적으로 함수의 리턴 타입으로 사용된다. 리턴 타입으로 `never`를 사용하면 오류를 출력하고 리턴 값을 생성하지 않음을 의미한다.

```typescript
const generateError = (message: string, code: number) => {
  throw { message: message, errCode: code };
};
generateError('에러 발생', 500);
```

<br>

### Enums

- 멤버라고 불리는 명명된 값의 집합을 이루는 자료형이다.
- 숫자로 표현하지만 사람이 읽기 쉽게 라벨링하는 개념이다.
- 해당 라벨들은 0부터 시작하는 숫자로 변환된다.
- 사용자 지정 타입이므로 첫 글자는 대문자로 입력하는 컨벤션을 지킨다.

```typescript
// Numeric enums
enum Direction {
  Up, // 0
  Down, // 1
  Left, // 2
  Right, // 3
}
console.log(Direction.Up); // 0

// Numeric enums 값 할당 가능. 값이 할당되지 않은 멤버는 이전 멤버 +1된 값이 할당된다.
enum Direction {
  Up = 10, // 10
  Down, // 11
  Left = 100, // 100
  Right, // 101
}
console.log(Direction[101]); // "Right"

// String enums - 각 멤버는 문자열 리터럴 또는 다른 문자열 열거형 멤버로 상수 초기화 해야 한다.
enum Direction {
  Up = 'UP',
  Down = 'DOWN',
  Left = 'LEFT',
  Right = 'RIGHT',
}
```

<br>

**Enums를 사용하는 이유**

1. 역할을 부여하는 코드를 작성했다고 가정해본다.
   ```typescript
   // 0 : DEVELOPER
   // 1 : ADMIN
   // 2 : GUEST
   const person = {
     name: '최개발',
     role: 0,
   };
   ```

<br>

2. 해당 숫자 '0'만으로는 개발자, 관리자, 게스트 중 어떤 역할을 수행하는지 알기 어려우며, 문자로된 식별자인 'DEVELOPER'가 이해하기 쉬울 것이다.
   ```typescript
   const person = {
     name: '최개발',
     role: 'DEVELOPER',
   };
   ```

<br>

3. 다만 문자로된 식별자는 if문으로 권한을 확인할 때 'DEVELOPER'로 작성했는지 'developer'로 작성했는지 확신하기 어렵다. 문자열을 어떻게 작성했는지 정확하게 기억해야하는 단점이 있다.
   ```typescript
   if (person.role === 'DEVELOPER') {...} // O
   if (person.role === 'developer') {...} // X
   ```

<br>

4. 3 번의 경우 보통 전역 상수를 선언하여 해결하곤 한다.

   ```typescript
   const DEVELOPER = 0;
   const ADMIN = 1;
   const GUEST = 2;

   if (person.role === DEVELOPER) {...}
   ```

<br>

5. 전역 상수로 선언한 경우 `role`은 `number` 타입으로 추론되어 입력하지 않은 모든 숫자가 저장된다. 또한 전역 상수를 선언하면 이 상수들을 정의하고 관리해야 한다. 지금까지의 문제점을 Enum을 통해 해결이 가능하다.

   ```typescript
   enum Role {
     DEVELOPER, // 0
     ADMIN, // 1
     GUEST, // 2
   }

   const person = {
     name: '최개발',
     role: Role.DEVELOPER,
   };

   if (person.role === Role.DEVELOPER) {...}
   ```

<br>

# Ref

- [TypeScript Docs](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
