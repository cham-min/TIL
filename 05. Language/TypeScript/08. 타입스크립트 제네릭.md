# 목차

- [제네릭(Generic)](#제네릭generic)
- [제네릭 타입 변수 활용](#제네릭-타입-변수-활용)
  - [매개변수의 길이를 출력하는 함수 생성하기](#매개변수의-길이를-출력하는-함수-생성하기)
  - [여러 개의 제네릭 타입 변수 사용하기](#여러-개의-제네릭-타입-변수-사용하기)
  - [첫 번째 인덱스 값을 반환하는 함수 생성하기](#첫-번째-인덱스-값을-반환하는-함수-생성하기)
- [제네릭 인터페이스 생성](#제네릭-인터페이스-생성)
- [제네릭 함수 생성](#제네릭-함수-생성)
  - [Generic Constraints(제네릭 제약조건)](#generic-constraints-제네릭-제약조건)
  - [keyof 제약 조건](#keyof-제약-조건)
- [Ref](#ref)

<br>

# 제네릭(Generic)

제네릭은 함수, 클래스, 인터페이스 등에서 사용할 수 있는 **타입 매개변수**를 통해 여러 종류의 타입에 대응하는 컴포넌트를 만들 수 있도록 해주는 기능이다. 이를 통해서 타입의 안정성을 높일 수 있다.

<br>

```typescript
function identity(arg: number): number {
  return arg;
}
```

`identity` 함수는 입력받은 값을 그대로 반환하는 함수이다. 제네릭을 사용하지 않으면 `identity` 함수에 어떤 타입의 인수를 받고, 어떤 타입을 반환할지 특정한 타입을 지정해 주어야 한다.

<br>

```typescript
function identity(arg: any): any {
  return arg;
}

let output = identity(100); // let output: any
```

특정한 타입을 지정하지 않고 `identity` 함수를 `any` 타입을 설정할 수 있다. `any`를 사용하면 `arg`가 어떤 타입이든 받을 수 있다는 점에서 제네릭이라고 할 수 있다. 하지만 함수에서 반환되는 값의 타입에 대한 정보를 잃어 `number` 타입을 넘기더라도 `any` 타입이 반환된다는 정보를 얻게된다.

<br>

```typescript
function identity<T>(arg: T): T {
  return arg;
}
```

무엇이 반환되는지 표시하고 인수의 타입을 캡처할 방법이 필요하여 값이 아닌 타입에 적용되는 타입 변수를 사용한다. `identify` 함수에 `T`라는 타입 변수를 추가했다. 타입 변수 `T`는 호출될 때 유저가 제공한 타입을 캡처하고, 해당 정보를 추후에 반환타입으로 다시 사용한다.

<br>

```typescript
// 1. 제네릭 타입을 명시하는 방법
let output = identity<string>('문자열'); // let output: string
// 2. 타입 추론을 이용하여 타입 명시를 안하는 방법
output = identify('문자열'); // let output: string

let output2 = identity<number>(123); // let output2: number
let output3 = identity<string | number>('문자열');
output3 = 123;
```

제네릭을 사용한 `identify` 함수를 작성하고 나면, 함수를 호출하는 방법은 두 가지가 있다.

1. 함수 호출시 타입 인수를 포함한 모든 인수를 전달하는 방법(`T`를 `string`으로 명시하고 `<>`로 감싼다)
2. 함수 호출시 타입 추론을 활용하여 컴파일러가 `T`의 값을 자동으로 정하게 하는 것

<br>

# 제네릭 타입 변수 활용

## 매개변수의 길이를 출력하는 함수 생성하기

제네릭을 사용하기 시작하면 제네릭 함수를 만들 때, 컴파일러가 함수 본문에서 제네릭으로 타입이 지정된 매개변수를 올바르게 쓰도록 강제한다. 제네릭 타입 변수가 사용된 매개변수들은 `any`나 모든 타입이 될 수 있는 것처럼 취급해야 한다.

만약 함수를 호출할 때 `arg`의 길이를 출력하고 싶다면 아래와 같이 작성하게 된다.

```typescript
function getLength<T>(arg: T) {
  return arg.length; // ❌ Property 'length' does not exist on type 'T'.
}

let foo = getLength([1, 2, 3]);
let foo2 = getLength('Hello, world!');
let foo3 = getLength({ length: 10 });
let foo4 = getLength(100); // ⚠️ 숫자형에는 length 속성이 없으므로 사용하면 안되지만 오류가 발생하지 않음
```

위 예시 코드에서 `arg`가 `length` 속성을 가지고 있지 않다는 오류가 발생한다. 타입 변수는 모든 타입이 될 수 있는데, `length` 멤버가 없는 `number`와 같은 타입을 전달할 수도 있다.

<br />

만약 함수가 `T`가 아닌 `T[]`에서 동작하도록 가정해보면, 배열이기 때문에 `length` 속성 사용이 가능하지만 배열이 아닌 다른 타입에서는 사용이 불가능하다.

```typescript
/**
 * function getLength<T>(arg: Array<T>): Array<T> {
 *  return arg.length;
 * }
 */
function getLength<T>(arg: T[]) {
  return arg.length;
}

let foo = getLength([1, 2, 3]);
let foo2 = getLength('Hello, world!'); // ❌ Argument of type 'string' is not assignable to parameter of type 'unknown[]'.
let foo3 = getLength({ length: 10 }); // ❌ Argument of type '{ length: number; }' is not assignable to parameter of type 'unknown[]'.
let foo4 = getLength(100); // ❌ Argument of type 'number' is not assignable to parameter of type 'unknown[]'.
```

<br>

이는 `extends` 키워드를 사용하여 `T`의 타입을 제한하여 해결할 수 있다.

```typescript
/**
 * 속성 length가 있는 객체를 확장하는 타입으로 T를 제한
 *  interface InterfaceA { length: number; }
 *  interface InterfaceB extends InterfaceA {}
 *  위에서 InterfaceB는 무조건 length: number 속성을 가지고 있어야 되는 원리와 같다.
 */
function getLength<T extends { length: number }>(arg: T) {
  return arg.length;
}

let foo = getLength([1, 2, 3]); // let foo: number
let foo2 = getLength('Hello, world!'); // let foo2: number
let foo3 = getLength({ length: 10 }); // let foo3: number
let foo4 = getLength(100); // ⚠️ 의도한대로 오류 발생: Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.
```

<br>

## 여러 개의 제네릭 타입 변수 사용하기

```typescript
// function swap(a: any, b: any) {} 대체
function swap<T>(a: T, b: T) {
  return [b, a];
}

const [a, b] = swap(1, 2); // ✅
const [c, d] = swap('1', 2); // ❌ Argument of type 'number' is not assignable to parameter of type 'string'.
```

`a`, `b` 매개변수를 받아서 순서를 바꾼 배열을 반환하는 `swap` 함수이다. `a`와 `b`가 같은 타입이면 문제가 없지만 다른 타입이라면 문제가 발생한다. 위의 경우 첫 번째 인수로 `string` 타입을 전달했으므로 타입 변수 `T`가 `string`으로 할당된다. 따라서 두 번째 인수 `b` 역시 `string`으로 할당되는데 `number` 값을 전달했기 때문에 발생한 오류이다.

<br />

위처럼 매개변수의 타입이 다를 수 있을 경우에는 타입 변수를 추가로 작성하면 된다.

```typescript
function swap<T, U>(a: T, b: U) {
  return [b, a];
}

const [a, b] = swap(1, 2);
const [c, d] = swap('1', 2);
```

<br>

## 첫 번째 인덱스 값을 반환하는 함수 생성하기

```typescript
// function getFirstIndex(data: any) {}
function getFirstIndex<T>(data: T) {
  /**
   * ❌
   * Element implicitly has an 'any' type because expression of type '0' can't be used to index type 'unknown'.
   * Property '0' does not exist on type 'unknown'.
   */
  return data[0];
}

let numValue = getFirstIndex([1, 2, 3]);
let strValue = getFirstIndex(['a', 'b', 'c']);
```

첫 번째 인덱스 값을 반환하는 `getFristIndex` 함수에서는 아직 할당될 `data`의 타입을 알 수 없기 때문에 오류가 발생하지 않도록 `unknown` 타입으로 간주되어 `0`이 존재하지 않는다는 오류가 발생한다.

<br>

```typescript
function getFirstIndex<T>(data: T[]) {
  return data[0];
}

let numValue = getFirstIndex([1, 2, 3]); // let numValue: number
let strValue = getFirstIndex(['a', 'b', 'c']); // let strValue: string
```

`T` 타입의 배열임을 명시해주면 오류가 발생하지 않는다.

<br>

```typescript
function getFirstIndex<T>(data: T[]) {
  return data[0];
}

let unionValue = getFirstIndex(['a', 1]); // let unionValue: string | number
```

만약 인수로 `string`과 `number`가 혼합된 배열을 전달하면 `T`는 `string | number` 타입이 된다. 따라서 첫 번째 인덱스 값도 `string`, `number` 중 하나가 아닌 `string | number` 타입이 된다. 만약 유니언 타입이 아닌 한 타입으로만 추론하고 싶다면 배열이 아닌 튜플 타입을 사용해볼 수 있다.

```typescript
function getFirstIndex<T>(data: [T, ...unknown[]]) {
  return data[0];
}

let unionValue = getFirstIndex(['a', 1]); // let unionValue: string
```

<br>

# 제네릭 인터페이스 생성

```typescript
interface Laptop {
  name: string;
  price: number;
  option: any;
}
```

`option` 속성에는 `null`, `string`, `object`등 어떤 타입이 들어올지 모르며 해당 타입들을 모두 나열하기 보다는 제네릭을 사용하는 것이 효율적이다.

```typescript
interface Laptop<T> {
  name: string;
  price: number;
  option: T;
}
```

<br>

```typescript
const apple: Laptop<object> = {
  // const apple: Laptop<{ color: string; ram: number }> = {
  name: 'mac',
  price: 250,
  option: {
    color: 'gray',
    ram: 16,
  },
};

const samsung: Laptop<string> = {
  name: 'galaxy',
  price: 200,
  option: 'i9',
};
```

제네릭을 활용하면 하나의 인터페이스를 통해서 다양한 객체를 생성할 수 있는 장점이 있다.

<br>

# 제네릭 함수 생성

두 객체를 병합하고 새 객체를 반환하는 함수를 만든다.

```typescript
function merge(objA: object, objB: object) {
  return Object.assign(objA, objB);
}

const mergedObj = merge({ name: '최개발' }, { age: 28 });
mergedObj.name; // Property 'name' does not exist on type 'object'.
```

`mergedObj`의 `name` 속성에 접근하지 못하는 모습이다. 이는 type assertion을 통해 해결할 수 있다.

```typescript
const mergedObj = merge({ name: '최개발' }, { age: 28 }) as {
  name: string;
  age: number;
};
```

<br>

제네릭 함수를 통해서 더욱 간단하게 작성할 수 있다. 정확히 어떤 타입이 될지는 모른다는 추가 정보를 제공하여 해당 타입에 대응할 수 있도록 하는 셈이다.

```typescript
function merge<T, U>(objA: T, objB: U) {
  return Object.assign(objA, objB);
}

const mergedObj = merge({ name: '최개발' }, { age: 28 });
console.log(mergedObj.age); // 28
```

<br>

### Generic Constraints (제네릭 제약조건)

```typescript
function merge<T, U>(objA: T, objB: U) {
  return Object.assign(objA, objB);
}

const mergedObj = merge({ name: '최개발', hobbies: ['코딩'] }, { age: 28 });

// Object.assign()은 열거 가능한 속성을 복사해 객체에 붙여넣기 때문에 30은 무시된다.
const mergedObj2 = merge({ name: '최개발', hobbies: ['코딩'] }, 30);
```

`merge` 함수의 경우 어떤 타입의 경우도 상관없이 허용하고 있다. 객체를 인수로 받을 의도와는 달리 `number` 타입의 값 `30`을 받게되었다. 의도를 명확히 하기 위해서 만약 두 매개변수 `T`, `U`가 어떤 타입의 객체여도 상관없이 항상 객체를 받길 원한다면 `extends` 키워드를 사용하여 **타입 제약 조건**을 사용할 수 있다.

```typescript
// T, U의 타입 변수는 object로 부터 확장되었음을 명시
function merge<T extends object, U extends object>(objA: T, objB: U) {
  return Object.assign(objA, objB);
}

const mergedObj = merge({ name: '최개발', hobbies: ['코딩'] }, 30);
// Argument of type 'number' is not assignable to parameter of type 'object'.
```

<br>

```typescript
function printName<T extends { name: string }>(objA: T): string {
  return objA.name;
}
```

또는 위 처럼 `name` 속성에 접근하는 함수를 만들었을 때, `T`타입의 매개변수를 받는데 `name` 속성이 `string`타입인 객체를 확장한 형태임을 명시할 수 있다.

<br>

### `keyof` 제약 조건

```typescript
function extractAndConvert(obj: object, key: string) {
  return obj[key];
}
```

위 `extractAndConvert` 함수는 객체와 키를 전달받아 객체 내의 키 값을 반환해주는 함수이다. 하지만 해당 객체가 `key`를 가지고 있는지 보장할 수 없어서 에러가 발생하게 된다. 제네릭을 사용하여 존재하지 않는 속성에 접근하려 했던 것을 방지해보자.

<br>

```typescript
function extractAndConvert<T extends object, U extends keyof T>(obj: T, key: U) {
  return obj[key];
}
```

<br>

# Ref

- [TypeScript Docs](https://www.typescriptlang.org/docs/handbook/2/generics.html)
- [김민준, 한 입 크기로 잘라먹는 타입스크립트(TypeScript)](https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%ED%81%AC%EA%B8%B0-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8)
- [Udemy TypeScript:기초부터 실전형 프로젝트까지](https://www.udemy.com/course/best-typescript-21/)
