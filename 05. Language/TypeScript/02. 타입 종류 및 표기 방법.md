# 목차

- [TypeScript 타입 종류](#typescript-타입-종류)
  - [The primitives](#the-primitives)
    - [변수 타입 표기](#변수-타입-표기)
  - [Arrays](#arrays)
  - [any](#any)
  - [Functions](#functions)
  - [Object Types](#object-types)
    - [Optional Properties](#optional-properties)
  - [Union Types](#union-types)
  - [Type Aliases](#type-aliases)
  - [Interfaces](#interfaces)
  - [Type Assertions](#type-assertions)
  - [Literal Types](#literal-types)
  - [null, undefined](#null-undefined)
  - [Enums](#enums)
- [Ref](#ref)

<br>

# TypeScript 타입 종류

### The primitives

- string
- number
- boolean

<br>

#### 변수 타입 표기

> 타입 추론 : 대부분의 경우 타입 표기는 필요하지 않으며, TypeScript는 자동으로 코드 내에 있는 타입을 추론한다.

```typescript
// 변수의 타입을 지정
const num: number = 1;
const str: string = '문자열';
const bool: boolean = true;

// 타입 추론 : 'name' 변수는 'string' 타입으로 추론된다.
const name = '홍길동';
```

<br>

### Arrays

- `number[]` - [1, 2, 3]과 같이 숫자로 이루어진 배열
- `string[]` - ['가', '나', '다']와 같이 문자열로 이루어진 배열

<br>

### any

- 특정 값으로 인하여 타입 검사 오류가 발생하는 것을 원하지 않는 경우
- 컴파일러 플래그 `noImplicitAny`를 사용하면 암묵적으로 `any`로 간주하는 모든 경우 에러를 발생시킨다.

<br>

### Functions

- TypeScript는 함수의 입력 및 출력 타입을 지정할 수 있다.
- 익명 함수의 경우 함수가 어떻게 호출되는지 알아내고 매개 변수에 자동으로 타입을 부여한다.<br>
  <img width="353" alt="image" src="https://user-images.githubusercontent.com/96946274/229846050-82081996-77c2-4022-9da8-e8196b70a562.png">

```typescript
// 1. 매개변수 타입 표기
const greet = (name: string) => {
  console.log('Hello, ' + name);
};

// 2. 반환 타입 표기
const getNumber = (): number => {
  return 28;
};
```

<br>

### Object Types

- 객체 타입은 프로퍼티와 각 프로퍼티 타입을 나열한다.
- 각 프로퍼티 타입 표기는 선택 사항이며, 타입을 지정하지 않으면 `any`로 간주한다.

```typescript
const person: {
  name: string;
  age: number;
  hobbies: string[];
} = {
  name: '최개발',
  age: 28,
  hobbies: ['Coding', 'Camping'],
};
```

<br>

#### Optional Properties

- 객체 타입은 모든 프로퍼티의 타입을 선택적 타입인 옵셔널(`?`)로 지정할 수 있다.

```typescript
const printName = (obj: { first: string; last?: string }) => {
  console.log(last + first);
};

printName({ first: '개발' });
printName({ first: '개발', last: '최' });
```

<br>

### Union Types

- 서로 다른 두 개 이상의 타입을 사용하여 만들며, 각 타입을 멤버라고 부른다.
- union 타입은 멤버 중 하나를 타입으로 갖는다.
- union 타입에 메서드를 사용하기 위해서는 모든 멤버에 유효한 작업이어야 한다.

```typescript
const printUpper = (str: string | string[]) => {
  console.log(str.toUpperCase());
  // Property 'toUpperCase' does not exist on type 'string | string[]'.
};

// 이를 해결하기 위해서는 if문으로 나눈다.
const printUpper = (strs: string | string[]) => {
  if (typeof strs === 'string') {
    console.log(strs.toUpperCase());
  } else {
    strs.forEach((str) => {
      console.log(str.toUpperCase());
    });
  }
};
```

<br>

### Type Aliases

- 같은 타입을 재사용하거나 타입에 이름을 붙이고 싶을 때 사용한다.

```typescript
type Person = {
  name: string;
  age: number;
};

const printPerson = (person: Person) => {
  console.log('Name : ' + person.name);
  console.log('Age : ' + person.age);
};
printPerson({ name: '최개발', age: 28 });
```

<br>

### Interfaces

```typescript
interface Person {
  name: string;
  age: number;
}

const printPerson = (person: Person) => {
  console.log(person.name);
  console.log(person.age);
};
printPerson({ name: '최개발', age: 28 });
```

- interface의 대부분 기능은 type alias에서도 가능하며 이름을 부여해주는 점이 동일하다.
- 차이점은 interface는 객체 타입에만 이름을 다는게 가능하지만, type alias는 모든 타입에 이름을 달 수 있다.

<img width="500" alt="image" src="https://user-images.githubusercontent.com/96946274/229854130-da06947b-7a2f-4334-ae7b-7261dcef25a9.png">

<br>

### Type Assertions

- TypeScript가 추론한 타입보다 본인이 타입에 대한 정보를 더 정확히 아는 경우 타입 단언을 통해서 조금 더 구체적으로 명시할 수 있다.
- 보다 구체적이거나 덜 구체적인 타입으로 변환하는 것만 허용되며 숫자형을 문자형으로 assertion 하는 것은 불가능하다.

```typescript
// TypeScript는 document.getElementById는 HTMLElement 중 무언가 반환된다는 것만 알고있다.
// const myCanvas: HTMLElement | null로 타입 추론
const myCanvas = document.getElementById('main_canvas');

// type assertion
const myCanvas2 = document.getElementById('main_canvas') as HTMLCanvasElement;

// type assertion2
const myCanvas2 = <HTMLCanvasElement>document.getElementById('main_canvas');
```

<br>

### Literal Types

- 구체적인 문자열, 숫자 값을 지정할 수 있다.
- 예시로 `boolean`타입은 실제로는 리터럴 타입으로 `true | false`의 별칭일 뿐이다.

```typescript
// 아래의 경우 일반적인 string 타입을 지정하지 않고 구체적인 문자를 지정했다.
const printText = (s: string, alignment: 'left' | 'right' | 'center') => {
  // ...
};
printText('Hello, world!', 'left');
```

<br>

### null, undefined

- 빈 값, 초기화되지 않은 값을 가리키는 원시값이다.
- `strictNullChecks` 옵션 설정에 따라서 동작 방식이 달라진다.

  - `strictNullChecks` 설정된 경우, `null` 혹은 `undefined`의 값을 가졌을 때 해당 값을 테스트해야 한다.
    ```typescript
    const undefinedTest = (str: string | undefined) => {
      if (str === undefined) {
        // undefined일 경우 수행할 동작
      } else {
        // string일 경우 수행할 동작
      }
    };
    ```
  - `strictNullChecks` 설정이 되지 않은 경우, `null` 혹은 `undefined`의 값을 가져도 해당 값에 평소와 같이 접근할 수 있다. Null 검사의 부재는 버그의 주요 원인이 되며 해당 옵션을 설정하는 것을 권장한다.
  - **Non-null Assertion 연산자** - 명시적인 검사를 하지 않고 `null`, `undefined`를 제거할 수 있는 구문으로 `!` 연산자를 표현식 뒤에 붙여서 해당 값이 `null` 혹은 `undefined`가 아님을 단언한다.

    ```typescript
    const validate = (e?: Entity) => {
      // 'e'는 null 혹은 유효한 값
    };

    const process = (e?: Entity) => {
      validate(e);
      const s = e!.name; // 'e'는 null이 아님을 단언하여 접근 가능하게 함.
    };
    ```

<br>

### Enums

- Numeric enums
  ```typescript
  enum Direction {
    Up = 1,
    Down, // 2
    Left, // 3
    Right, // 4
  }
  ```
  `Up`이 1로 초기화된 숫자 열거형을 선언하면, 뒤따르는 멤버들은 자동으로 증가된 값을 갖는다. 초기화하지 않는다면 `Up`값은 자동으로 0으로 초기화되며, `Down`은 1이 된다.
- String enums
  ```typescript
  enum Direction {
    Up = 'UP',
    Down = 'DOWN',
    Left = 'LEFT',
    Right = 'RIGHT',
  }
  ```
  문자열 열거형 각 멤버는 문자열 리터럴 또는 다른 문자열 열거형 멤버로 상수 초기화 해야 한다.

<br>

# Ref

- [TypeScript Docs](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
