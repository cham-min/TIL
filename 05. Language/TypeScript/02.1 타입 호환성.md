# λ©μ°¨

- [κµ¬μ΅°μ  μ„λΈ νƒ€μ΄ν•‘(Structural Subtyping)](#κµ¬μ΅°μ -μ„λΈ-νƒ€μ΄ν•‘structural-subtyping)
- [νƒ€μ… νΈν™μ„±(Type Compatibility)](#νƒ€μ…-νΈν™μ„±type-compatibility)
  - [κΈ°λ³Έ νƒ€μ… νΈν™μ„±](#κΈ°λ³Έ-νƒ€μ…-νΈν™μ„±)
  - [κ°μ²΄ νƒ€μ… νΈν™μ„±](#κ°μ²΄-νƒ€μ…-νΈν™μ„±)
- [Ref](#ref)

<br>

# κµ¬μ΅°μ  μ„λΈ νƒ€μ΄ν•‘(Structural Subtyping)

νƒ€μ… νΈν™μ„±μ„ μ΄ν•΄ν•κΈ° μ„ν•΄μ„ μ£Όμ” κ°λ…μΈ λ…λ©μ  νƒ€μ΄ν•‘, κµ¬μ΅°μ  νƒ€μ΄ν•‘, κµ¬μ΅°μ  μ„λΈ νƒ€μ΄ν•‘μ— λ€ν•΄μ„ μ΄ν•΄ν•  ν•„μ”κ°€ μλ‹¤.

<strong>λ…λ©μ  νƒ€μ΄ν•‘(Nominal Typing)</strong>μ€ νƒ€μ…μ μ΄λ¦„μ„ κΈ°λ°μΌλ΅ νΈν™μ„±μ„ κ²°μ •ν•λ‹¤. Java, C#, C++κ³Ό κ°™μ€ μ–Έμ–΄λ“¤μ΄ μ‚¬μ©ν•λ”λ°, κµ¬μ΅°κ°€ λ™μΌν•΄λ„ μ΄λ¦„μ΄ λ‹¤λ¥΄λ‹¤λ©΄ νΈν™λμ§€ μ•λ”λ‹¤. λ…μ‹μ μΈ μƒμ† κ΄€κ³„λ‚ μΈν„°νμ΄μ¤ κµ¬ν„ν•΄μ•Ό ν•λ―€λ΅ νƒ€μ… μ•μ •μ„±μ΄ λ†’κ³  μλ„ν•μ§€ μ•μ€ νƒ€μ… νΈν™μ„ λ°©μ§€ν•  μ μλ‹¤.

```java
// Java
class Person {
  String name;
  int age;
}

class Employee {
  String name;
  int age;
}

Person person = new Person();
Employee employee = person; // β Error β®• incompatible types: Person cannot be converted to Employee
```

<br>

<strong>κµ¬μ΅°μ  νƒ€μ΄ν•‘(Structural Typing)</strong>μ€ νƒ€μ…μ μ‹¤μ  κµ¬μ΅°λ‚ λ¨μ–‘μ„ κΈ°λ°μΌλ΅ νƒ€μ… νΈν™μ„±μ„ κ²°μ •ν•λ‹¤. νƒ€μ…μ μ΄λ¦„μ΄ μ•„λ‹ νƒ€μ…μ΄ κ°€μ§„ ν”„λ΅νΌν‹°μ™€ λ©”μ„λ“λ΅ κµ¬μ΅°λ¥Ό λΉ„κµν•λ‹¤. TypeScript, Goμ™€ κ°™μ€ μ–Έμ–΄λ“¤μ΄ μ‚¬μ©ν•λ©°, μ μ—°μ„±μ΄ λ†’κ³  μ½”λ“ μ¬μ‚¬μ©μ„±μ΄ λ†’λ‹¤.

```typescript
// TypeScript
interface Person {
  name: string;
  age: number;
}

interface Employee {
  name: string;
  age: number;
}

let person: Person = { name: 'μµκ°λ°', age: 30 };
let employee: Employee = person; // β…
```

<br>

λ§μ§€λ§‰μΌλ΅ κµ¬μ΅°μ  μ„λΈνƒ€μ΄ν•‘(Structural Subtyping)μ€ κµ¬μ΅°μ  νƒ€μ΄ν•‘μ ν• ν•νƒλ΅, ν• νƒ€μ…μ΄ λ‹¤λ¥Έ νƒ€μ…μ λ¨λ“  λ©¤λ²„λ¥Ό ν¬ν•¨ν•  λ• μ„λΈνƒ€μ… κ΄€κ³„κ°€ μ„±λ¦½ν•λ‹¤.

```typescript
// TypeScript
interface Animal {
  name: string;
}

interface Dog {
  name: string;
  breed: string;
}

let animal: Animal;
let dog: Dog = { name: 'λ―Ώμμ΄', breed: 'μ§„λ—κ°' };

animal = dog; // β… Dogλ” Animalμ λ¨λ“  λ©¤λ²„λ¥Ό ν¬ν•¨ν•λ―€λ΅ νΈν™ κ°€λ¥
// dog = animal; // β Animalμ€ breed λ©¤λ²„κ°€ μ—†μΌλ―€λ΅ νΈν™ λ¶κ°€
```

<br>

# νƒ€μ… νΈν™μ„±(Type Compatibility)

> π’­ λ²”μ„κ°€ λ„“μ€ νƒ€μ…(μνΌ ν΄λμ¤)μ—λ§ μΆμ€ νƒ€μ…(μ„λΈ ν΄λμ¤) ν• λ‹Ήμ΄ κ°€λ¥ν•λ‹¤.

| νƒ€μ… β†’        | any | unknown | object | void | undefined | null | never |
| ------------- | --- | ------- | ------ | ---- | --------- | ---- | ----- |
| **any**       |     | β…      | β…     | β…   | β…        | β…   | β    |
| **unknown**   | β…  |         | β     | β   | β        | β   | β    |
| **object**    | β…  | β…      |        | β   | β        | β   | β    |
| **void**      | β…  | β…      | β     |      | β        | β   | β    |
| **undefined** | β…  | β…      | β…     | β…   |           | β…   | β    |
| **null**      | β…  | β…      | β…     | β…   | β…        |      | β    |
| **never**     | β…  | β…      | β…     | β…   | β…        | β…   |       |

<br>

## κΈ°λ³Έ νƒ€μ… νΈν™μ„±

```typescript
let num: number = 1;
let literalNum: 1 = 1;

num = literalNum; // β… upcasting: μ«μν• νƒ€μ…μ— λ¦¬ν„°λ΄ μ«μ ν• λ‹Ή κ°€λ¥
literalNum = num; // β downcasting: λ¦¬ν„°λ΄ μ«μ νƒ€μ…μ— μ«μν• νƒ€μ… ν• λ‹Ή λ¶κ°€
```

<br>

## κ°μ²΄ νƒ€μ… νΈν™μ„±

> π’­ κ°μ²΄μ— λ©¤λ²„κ°€ λ§μ„μλ΅ λ²”μ„κ°€ λ„“μ€ μνΌν΄λμ¤λ΅ λ³΄μ—¬μ„ μ΄ν•΄ν•κΈ° μ–΄λ ¤μ› μ—λ‹¤. ν•μ§€λ§ λΉ κ°μ²΄κ°€ μ μΌ λ„“μ€ λ²”μ„μ΄κ³  λ©¤λ²„λ¥Ό μ¶”κ°€ν• μλ΅ λ¦¬ν„°λ΄ κ°’μ„ μ¶”κ°€ν•λ” κ²ƒμΌλ΅ μƒκ°ν•λ‹ μ΄ν•΄ν•κΈ° μμ›”ν–λ‹¤.

```typescript
type Animal = {
  name: string;
  age: number;
};

type Dog = {
  name: string;
  age: number;
  breed: string;
};

let animal: Animal = { name: 'ν† λΌ', age: 3 };
let dog: Dog = { name: 'νƒ„μ΄', age: 3, breed: 'μ‚½μ‚΄κ°' };

animal = dog; // β… upcasting: Dogλ” Animalμ λ¨λ“  λ©¤λ²„λ¥Ό ν¬ν•¨
dog = animal; // β downcasting: Animalμ€ Dogμ λ¨λ“  λ©¤λ²„λ¥Ό λ―Έν¬ν•¨
```

<br>

`Animal`κ³Ό `Dog`νƒ€μ…μ μμ λ¥Ό μ‚΄ν΄λ³΄λ©΄μ„ κ°μ²΄λ„ μ—…μΊμ¤ν…μ΄ κ°€λ¥ν• κ²ƒμ„ ν™•μΈν–λ‹¤. ν•μ§€λ§ μ§μ ‘ ν• λ‹Ήν•΄λ³΄λ©΄ λ‹¤μκ³Ό κ°™μ€ λ¬Έμ κ°€ λ°μƒν•λ‹¤.

```typescript
type Animal = {
  name: string;
  age: number;
};

type Dog = {
  name: string;
  age: number;
  breed: string;
};

let rabbit: Animal = { name: 'ν† λΌ', age: 3, breed: 'κµ΄ν† λΌ' };
// β Object literal may only specify known properties, and 'breed' does not exist in type 'Animal'.
```

`Animal` νƒ€μ…μ— `Dog` νƒ€μ…μ κ°μ²΄λ¥Ό μ§μ ‘ ν• λ‹Ήν•λ©΄ μ—…μΊμ¤ν…μ„μ—λ„ λ¶κµ¬ν•κ³  `breed` ν”„λ΅νΌν‹°κ°€ μ—†λ‹¤λ” μ¤λ¥κ°€ λ°μƒν•λ‹¤. μ΄λ” νƒ€μ…μ¤ν¬λ¦½νΈμ μ΄κ³Ό μ†μ„± κ²€μ‚¬(_κ°μ²΄ λ¦¬ν„°λ΄μ΄ νΉμ • νƒ€μ…μ— μ§μ ‘ ν• λ‹Ήλ  λ•λ§ λ°μƒν•λ” μ—„κ²©ν• κ²€μ‚¬μ΄λ©°, μλ»λ μ†μ„±λ…μ„ μ‚¬μ©ν•λ” κ²ƒμ„ λ°©μ§€ν•κΈ° μ„ν•΄μ„ μ •μλμ§€ μ•μ€ μ†μ„±μ„ κ°μ§€_) λ•λ¬Έμ— λ°μƒν•λ” λ¬Έμ μ΄λ‹¤.

<br>

## ν•¨μ νƒ€μ… νΈν™μ„±

ν•¨μ νƒ€μ… νΈν™μ„± λν• κµ¬μ΅°μ  νƒ€μ΄ν•‘ κΈ°λ°μΌλ΅ μ‘λ™ν•λ‹¤. ν•¨μμ λ§¤κ°λ³€μμ™€ λ°ν™κ°’μ νƒ€μ…μ΄ λ‹¤μ κ·μΉ™λ“¤μ„ λ§μ΅±ν•λ©΄, λ‘ ν•¨μ νƒ€μ…μ΄ νΈν™λλ‹¤.

<br>

μ²« λ²μ§Έ κ·μΉ™μ€ "**λ°ν™κ°’μ νƒ€μ…μ΄ νΈν™λλ”κ°€?**"μ΄λ‹¤. μ΄λ¥Ό λ°ν™ νƒ€μ…μ κ³µλ³€μ„±(Covariance)μ΄λΌκ³  ν•λ‹¤. ν• λ‹Ήλλ” ν•¨μμ λ°ν™ νƒ€μ…μ΄ ν• λ‹Ήλ°›λ” ν•¨μμ λ°ν™ νƒ€μ…κ³Ό κ°™κ±°λ‚ λ” κµ¬μ²΄μ μ΄μ–΄μ•Ό ν•λ‹¤. μ¦‰, ν• λ‹Ήλ°›λ” ν•¨μμ λ°ν™ νƒ€μ…μ΄ λ” λ„“μ€ λ²”μ„(μνΌνƒ€μ…)μ΄μ–΄μ•Ό ν•λ‹¤.

> π’­ λ°ν™κ°’μ νƒ€μ…μ€ μ§€κΈκΉμ§€ λ‚΄μ©λ€λ΅ μ—…μΊμ¤ν…μΌ κ²½μ°μ— νΈν™μ΄ λλ‹¤.

```typescript
type ReturnAnimal = () => { name: string };
type ReturnDog = () => { name: string; breed: string };

let animal: ReturnAnimal = () => ({ name: 'λ―Ώμμ΄' });
let dog: ReturnDog = () => ({ name: 'λ―Ώμμ΄', breed: 'μ§„λ—κ°' });

animal = dog; // β…
// dog = animal; // β Type 'ReturnAnimal' is not assignable to type 'ReturnDog'. Property 'breed' is missing in type '{ name: string; }' but required in type '{ name: string; breed: string; }'.
```

<br>

λ‘ λ²μ§Έ κ·μΉ™μ€ "**λ§¤κ°λ³€μμ νƒ€μ…μ΄ νΈν™λλ”κ°€?**"μ΄λ‹¤. μ΄λ¥Ό λ§¤κ°λ³€μ νƒ€μ…μ λ°κ³µλ³€μ„±(Contravariance)μ΄λΌκ³  ν•λ‹¤. ν• λ‹Ήλλ” ν•¨μμ λ§¤κ°λ³€μ νƒ€μ…μ΄ ν• λ‹Ήλ°›λ” ν•¨μμ λ§¤κ°λ³€μ νƒ€μ…κ³Ό κ°™κ±°λ‚ λ” μ¶”μƒμ μ΄μ–΄μ•Ό ν•λ‹¤. μ¦‰, ν• λ‹Ήλ°›λ” ν•¨μμ λ§¤κ°λ³€μ νƒ€μ…μ΄ λ” μΆμ€ λ²”μ„(μ„λΈνƒ€μ…)μ΄μ–΄μ•Ό ν•λ‹¤.

> π’­ λ§¤κ°λ³€μμ νƒ€μ…μ€ μ§€κΈκΉμ§€ λ‚΄μ©κ³Όλ” λ‹¤λ¥΄κ² μ—…μΊμ¤ν…μ€ ν—μ©λμ§€ μ•κ³  λ‹¤μ΄μΊμ¤ν…μ΄ ν—μ©λλ‹¤.

```typescript
type AcceptAnimal = (animal: { name: string }) => void;
type AcceptDog = (dog: { name: string; breed: string }) => void;

let animal: AcceptAnimal = (animal) => console.log(animal.name);
let dog: AcceptDog;

dog = animal;
animal = dog; // β Type 'AcceptDog' is not assignable to type 'AcceptAnimal'. Types of parameters 'dog' and 'animal' are incompatible. Property 'breed' is missing in type '{ name: string; }' but required in type '{ name: string; breed: string; }'.

/**
 * λ§¤κ°λ³€μμ μ—…μΊμ¤ν…μ„ λ§‰λ” μ΄μ λ” μ•„λμ™€ κ°™μ€ μ½”λ“λ¥Ό λ°©μ§€ν•κΈ° μ„ν•¨μ΄λ‹¤.
 * let animal: AcceptAnimal = (animal) => {
 *   console.log(animal.name);
 *   console.log(animal.breed);
 * }
 *
 * λ°λ€λ΅ λ‹¤μ΄μΊμ¤ν…μ„ ν–μ„ λ•μ—λ” λ§¤κ°λ³€μκ°€ λ¨λ“  ν”„λ΅νΌν‹°λ¥Ό κ°€μ§€κ³  μμΌλ―€λ΅ μ½”λ“μ— λ¬Έμ κ°€ μ—†λ‹¤.
 */
```

<br>

λ‹¤μμΌλ΅ λ§¤κ°λ³€μ κ°μκ°€ λ‹¤λ¥Έ λ‘ ν•¨μλ” **λ” μ μ€ λ§¤κ°λ³€μλ¥Ό κ°€μ§„ ν•¨μλ¥Ό λ” λ§μ€ λ§¤κ°λ³€μλ¥Ό κ°€μ§„ ν•¨μ νƒ€μ…μ— ν• λ‹Ή**ν•  μ μλ‹¤.

> π’­ λ§¤κ°λ³€μ νƒ€μ…μ λ°κ³µλ³€μ„±κ³Ό λΉ„μ·ν•΄λ³΄μ΄μ§€λ§ λ°κ³µλ³€μ„±μ€ νƒ€μ… κ³„μΈµ κµ¬μ΅°μ—μ„ μ„λΈνƒ€μ… κ΄€κ³„κ°€ λ’¤λ°”λ€λ” λ§¤κ°λ³€μ νƒ€μ…μ— κ΄€ν• κ²ƒμ΄κ³ , λ§¤κ°λ³€μ κ°μκ·μΉ™μ€ κ³„μΈµκ³Ό λ¬΄κ΄€ν• ν•¨μ μ‹κ·Έλ‹μ² κµ¬μ΅°(JavaScriptμ—μ„ ν•¨μλ” μ¶”κ°€ μΈμλ¥Ό λ¬΄μ‹)μ— κ΄€ν• κ²ƒμ΄λ‹¤.

```typescript
type Func1 = (a: number) => void;
type Func2 = (a: number, b: number) => void;

let func1: Func1 = (a) => console.log(a);
let func2: Func2;

func2 = func1; // β…
// func1 = func2; // β
```

<br>

# Ref

- [TypeScript Docs](https://www.typescriptlang.org/ko/docs/handbook/type-compatibility.html)
- [[toss tech] TypeScript νƒ€μ… μ‹μ¤ν… λ―μ–΄λ³΄κΈ°: νƒ€μ… νΈν™μ„±
  ](https://toss.tech/article/typescript-type-compatibility)
