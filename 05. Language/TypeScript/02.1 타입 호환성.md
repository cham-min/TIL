# 목차

- [구조적 서브 타이핑(Structural Subtyping)](#구조적-서브-타이핑structural-subtyping)

<br>

# 구조적 서브 타이핑(Structural Subtyping)

타입 호환성을 이해하기 위해서 주요 개념인 명목적 타이핑, 구조적 타이핑, 구조적 서브 타이핑에 대해서 이해할 필요가 있다.

<strong>명목적 타이핑(Nominal Typing)</strong>은 타입의 이름을 기반으로 호환성을 결정한다. Java, C#, C++과 같은 언어들이 사용하는데, 구조가 동일해도 이름이 다르다면 호환되지 않는다. 명시적인 상속 관계나 인터페이스 구현해야 하므로 타입 안정성이 높고 의도하지 않은 타입 호환을 방지할 수 있다.

```java
// Java
class Person {
  String name;
  int age;
}

class Employee {
  String name;
  int age;
}

Person person = new Person();
Employee employee = person; // ❌ Error ⮕ incompatible types: Person cannot be converted to Employee
```

<br>

<strong>구조적 타이핑(Structural Typing)</strong>은 타입의 실제 구조나 모양을 기반으로 타입 호환성을 결정한다. 타입의 이름이 아닌 타입이 가진 프로퍼티와 메서드로 구조를 비교한다. TypeScript, Go와 같은 언어들이 사용하며, 유연성이 높고 코드 재사용성이 높다.

```typescript
// TypeScript
interface Person {
  name: string;
  age: number;
}

interface Employee {
  name: string;
  age: number;
}

let person: Person = { name: '최개발', age: 30 };
let employee: Employee = person; // ✅
```

<br>

마지막으로 구조적 서브타이핑(Structural Subtyping)은 구조적 타이핑의 한 형태로, 한 타입이 다른 타입의 모든 멤버를 포함할 때 서브타입 관계가 성립한다.

```typescript
// TypeScript
interface Animal {
  name: string;
}

interface Dog {
  name: string;
  breed: string;
}

let animal: Animal;
let dog: Dog = { name: '믿음이', breed: '진돗개' };

animal = dog; // ✅ Dog는 Animal의 모든 멤버를 포함하므로 호환 가능
// dog = animal; // ❌ Animal은 breed 멤버가 없으므로 호환 불가
```
