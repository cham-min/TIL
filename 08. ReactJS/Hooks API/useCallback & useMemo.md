# 목차

- [Memoization](#memoization)
- [들어가기 전, 어떤 것을 최적화 하는지 이해하기](#들어가기-전-어떤-것을-최적화-하는지-이해하기)
  - [React 렌더링](#react-렌더링)
  - [React 렌더링 과정](#react-렌더링-과정)
- [useCallback](#usecallback)
  - [useCallback 목적](#usecallback-목적)
- [useMemo](#usememo)
  - [useMemo 목적](#usememo-목적)
  - [useMemo 예시](#usememo-예시)
- [언제 Memoization을 사용해야 할까?](#언제-memoization을-사용해야-할까)
- [Ref](#ref)

<br>

# Memoization

`useCallback`, `useMemo`를 학습하기에 앞서 메모이제이션을 우선 이해해야 했다. 메모이제이션이란 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다(출처 : [위키백과](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98) ).

최적화를 위한 Memoization이 React에서 필요한 이유는 무엇일까? 함수 컴포넌트는 근본적으로 함수인데 React는 매 렌더링마다 함수 컴포넌트를 다시 호출한다. 함수는 기본적으로 이전 호출과 새로운 호출간에 값을 공유할 수 없다. 만약 특정한 함수 호출 내에서 만들어진 변수를 다음 함수 호출에도 사용하고 싶다면 그 값을 함수 외부의 특정한 공간에 저장해뒀다가 다음 호출 때 명시적으로 다시 꺼내와야 한다.

이것을 직접 구현하는 것은 꽤나 번거로운 일이고, 특히 함수 컴포넌트에서 이를 구현하고 관리하는 것은 많은 노력이 드는 행위이다. React에서는 함수 컴포넌트에서 값을 memoization 할 수 있도록 API를 제공하고있다.

<br>

# 들어가기 전, 어떤 것을 최적화 하는지 이해하기

### React 렌더링

React에서 렌더링은 화면에 특정한 요소를 그려내는 것이며, 브라우저에서의 렌더링은 DOM 요소를 계산하고 그려내는 것이다. 개발자는 브라우저에서 제공되는 DOM API를 JavaScript를 통해 호출하면서 브라우저에 그려진 화면을 변화시킨다.

VanillaJS를 통해서 DOM에 직접 접근하고 수정하는 '명령형' 방식은 애플리케이션 규모가 커질수록 관리하기 힘들어진다. 그래서 개발자들은 애플리케이션에서 보여주고 싶은 UI를 선언만하면 UI를 그려내고, 변화시키는 일은 라이브러리, 프레임워크가 대신 해주는 '선언적' 개발 방식을 찾게된다.

이처럼 React는 선언형으로 실제 렌더링 과정을 대신 처리해주고 개발자는 UI를 설계하는데 집중하게 도와준다. 때로는 React 내부에서 렌더링을 최적화해야 하는 상황이 생긴다. 이 때 React 내부적으로 렌더링이 언제 발생하고 어떤 과정을 거쳐서 이루어지는지 이해해야 렌더링을 최적화할 수 있다.

<br>

### React 렌더링 과정

React에서 `state`를 사용하는 이유는 UI와 상태를 연결시키기 위해서이다. UI는 데이터가 있으며 이를 보기 편한 형태로 표현한 것이다. React는 UI와 연동되고 변할 여지가 있는 데이터를 `state` 형태로 사용할 수 있도록했다. 그리고 데이터가 변경되었을 때 UI가 맞춰서 변화하기 위해서 `state`를 변경시키는 방법을 `setState`와 같은 형태로 제한하고 해당 함수가 호출될 때마다 리렌더링이 되도록 설계했다.

이러한 이유로 React의 리렌더링 시점은 `state`가 변했을 때이다. 특정 컴포넌트의 `state`가 변한다면 해당 컴포넌트와 하위에 있는 모든 컴포넌트에 리렌더링이 발생한다. `state`가 변했을 때 해당 컴포넌트를 포함한 하위 컴포넌트들이 모두 리렌더링 된다라는 명확한 모델을 이해하고 있는 것이 React를 이용해서 애플리케이션을 설계하고 최적화하는데 기본이 되는 사항이다.

`state`값이 변하고 브라우저상 UI에 반영되기까지 각 컴포넌트는 4단계를 거친다.

1. 기존 컴포넌트의 UI를 재사용할지 확인한다.
2. 함수 컴포넌트 : 컴포넌트 함수를 호출한다. / 클래스 컴포넌트 : `render` 메서드를 호출한다.
3. 2의 결과를 통해서 새로운 VirtualDOM을 생성한다.
4. 이전의 VirtualDOM과 새로운 VirtualDOM을 비교해서 실제 변경된 부분만 DOM에 적용한다.

왜 VirtualDOM을 사용할까? 브라우저는 화면을 보여주기 위해서 HTML, CSS, JavaScript를 다운로드 받고 이를 처리해서 화면에 픽셀 형태로 그려낸다. 이 과정을 CRP(Criticla Rendering Path)라고 부른다. CRP는 아래의 과정을 수행한다.

1. HTML을 파싱해서 DOM을 만든다.
2. CSS를 파싱해서 CSSOM을 만든다.
3. DOM과 CSSOM을 결합해서 Render Tree를 만든다.
4. Render Tree와 Viewport의 width를 통해서 각 요소들의 위치와 크기를 계산한다(**Layout**)
5. 지금까지 계산된 정보를 이용해 Render Tree상의 요소들을 실제 픽셀로 그려낸다(**Paint**)

DOM 또는 CSSOM이 수정될 때 마다 위의 과정을 반복한다. UI를 변화하기 위해서는 많은 DOM 조작이 필요하다.매 DOM조작마다 CRP가 수행될 것이고 이는 곧 브라우저에게 많은 연산을 요구하게 되어 퍼포먼스를 저하시키는 요인이 된다. 따라서 이 과정을 최적화 하는 것이 퍼포먼스상에 중요한 포인트이다. 그런데 위 과정중에서 Layout, Paint 과정은 특히나 많은 계산을 필요로하는 부분이다. 따라서 React는 이 CRP가 수행되는 횟수를 최적화 하기 위해서 VirtualDOM을 사용하는 것이다.

이렇게 UI를 변화시킬 때마다 많은 연산을 수행하는데 개발자가 할 수 있는 최적화 중 하나는 기존 컴포넌트의 UI를 재사용하는 것이다. 만약 리렌더링 될 컴포넌트의 UI가 이전의 UI와 동일하다고 판단되는 경우 새롭게 컴포넌트 함수를 호출하지 않고 이전의 결과값을 그대로 사용하도록 함으로써 최적화를 수행할 수 있다.

<br>

# `useCallback`

```javascript
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]); // a 혹은 b 변수값이 바뀌었을 때만 새로운 함수를 생성한다.
```

- 메모이제이션된 콜백을 반환한다. 즉 함수를 메모이제이션 하기 위해서 사용하는 hook이다.
- 첫 번째 파라미터에는 사용하고 싶은 함수를, 두 번째 파라미터에는 어떤 값이 바뀌었을 때 함수를 새로 생성할지 명시하는 의존성 배열(dependency array)을 넣는다.
- `useCallback` hook을 사용하면 dependency array 값이 바뀌지 않는 한 만들어 놓은 함수를 계속해서 재사용한다.

<br>

### `useCallback` 목적

React 컴포넌트 내에 함수가 선언 되어 있다면, 해당 함수는 컴포넌트가 리렌더링될 때마다 **새로 만들어진 함수를 사용**한다. 대부분의 경우 성능 상 큰 문제는 없지만 `useCallback`을 사용하여 렌더링이 자주 발생하거나 렌더링 할 컴포넌트의 개수가 많아질 때 최적화할 수 있다.

<br>

# `useMemo`

```javascript
// useMemo(callbackFunction, deps)
const memoizedValue = useMemo(() =>
  computeExpensiveValue(a, b);
, [a, b]);
```

- `useCallback`과 비슷하지만 메모이제이션된 함수를 반환하는 대신 메모이제이션된 **값**을 반환한다.
- `useMemo`를 사용하여 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있다.

<br>

### `useMemo` 목적

컴포넌트 리렌더링이 일어났을 때, 값이 바뀌지 않는 경우에는 함수를 호출할 필요가 없다. 예를 들어서 덧셈을 계산하는 함수가 있을 때, `x + y`를 반환한다고 해보자. 여기서 `x`와 `y`의 값이 바뀌지 않는다면, 렌더링 할때마다 계산을 한다면 낭비이다.

`useMemo` 훅은 위와 같은 작업을 최적화할 수 있고, 렌더링 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용한다.

<br>

### `useMemo` 예시

#### 1. 태그에 스타일 객체를 넣지 말자.

리렌더링 될 때마다 컴포넌트 함수 전체가 실행되는데, 객체끼리 비교(`{} === {}`)하면 결과는 `false`이다.

```javascript
<div style={{ margin: 10 }}></div>
```

React는 Virtual DOM으로 어느 부분이 달라졌는지 탐색하다가 실제로는 객체의 값 `margin: 10`이 바뀌지 않았지만, 객체가 다르다고 인지하여 리렌더링 된다. 이러한 문제를 해결하기 위해서 이미 스타일이 적용된 styled-component 혹은 `useMemo`를 이용한다.

```javascript
const memoStyle = useMemo(() => ({ marginTop: 10 }), []);
...
<div style={{ memoStyle }}></div>
```

<br>

# 언제 Memoization을 사용해야 할까?

개념만 보았을 때 굉장히 효율적이고 사용만하면 최적화가 이루어질 것 같다. 그렇지만 명확한 목적없이 모든 값, 함수에 `useMemo`, `useCallback`을 사용하는 것은 비효율적이다. 메모이제이션 전에는 아래 사항을 생각해봐야 한다.

1. 새로운 값을 만드는 것
2. 어딘가에 이전의 값을 저장해두고 메모이제이션한 값 혹은 함수를 호출하여 의존성을 비교하여 가져올 것인지에 대한 여부

위 두가지 중에서 어느 것이 비용이 적게 드는지 고민해봐야 한다.

새로운 값을 만드는 과정이 복잡하다면 메모이제이션을 활용하는 것이 효율적일 수 있다. 하지만 값을 만드는 과정이 복잡하지 않다면 메모이제이션을 사용하는 것이 오히려 더 많은 비용이 들수있다. 이처럼 메모이제이션은 무조건 사용하기 보다는 필요성을 분석하고 필요하다고 판단되는 순간에만 사용해야한다. 이를 판단할수 있는 요인은 아래 두 가지이다.

1. 새로운 값을 만드는 연산이 복잡하다.
2. 함수 컴포넌트의 이전 호출과 다음 호출 간 사용하는 값(혹은 메모리 주소)의 동일성을 보장하고 싶다.

2 번의 경우를 더욱 자세히 말하자면 `React.memo`와 연동해서 사용할 때 props로 전달되는 객체(함수)의 동일성이 보장되지 않아서 실제 값은 동일하지만 shallow compare를 통해서 다른 객체라고 판단되어 매번 리렌더링이 되는 경우를 방지하고자 할 때 메모이제이션을 사용할 수 있다.

<br>

# Ref

- React트 공식문서](https://ko.reactjs.org/docs/hooks-reference.html#usecallback)
- 리액트를 다루는 기술, 김민준(VELOPERT)
